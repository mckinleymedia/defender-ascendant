<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defender Ascendant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #000000; /* Deep black for space */
            color: #00FFFF; /* Cyan for text */
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column; /* Stack canvas and UI */
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative; /* For positioning UI elements over/around canvas */
            border: 2px solid #00FFFF;
            box-shadow: 0 0 15px #00FFFF, 0 0 25px #00FFFF inset;
            background-color: #001018; /* Dark blue-ish space backdrop */
            width: 800px;
        }
        canvas {
            display: block; /* Removes extra space below canvas */
            background-image:
                radial-gradient(circle at 1px 1px, rgba(255,255,255,0.3) 1px, transparent 0),
                radial-gradient(circle at 10px 10px, rgba(255,255,255,0.15) 1px, transparent 0);
            background-size: 30px 30px; /* Creates a subtle starfield */
        }
        #ui-radar-container {
            width: 80%;
            max-width: 800px; /* Match canvas width */
            margin-top: 5px;
            height: 60px; /* Increased height for radar and other info */
            position: relative;
            background-color: rgba(0, 20, 20, 0.6);
            border: 1px solid #00AAAA;
            border-top: none; 
            box-sizing: border-box;
        }
        #radar {
            width: 100%;
            height: 25px; /* Dedicated radar strip */
            background-color: rgba(0, 10, 10, 0.7);
            border-bottom: 1px solid #007777;
            position: relative; /* For positioning dots */
            overflow: hidden;
        }
        .ui-text {
            padding: 0 10px;
            font-size: clamp(12px, 2vw, 16px); /* Responsive font size */
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 35px; /* Remaining height in ui-radar-container */
        }
        .score, .lives, .bombs, .shield-status, .wave {
             text-shadow: 0 0 5px #00FFFF;
        }
        #shield-bar-container {
            display: inline-block;
            width: 80px;
            height: 10px;
            background-color: #003333;
            border: 1px solid #00AAAA;
            border-radius: 3px;
            overflow: hidden;
            margin-left: 5px;
        }
        #shield-fill {
            display: block;
            height: 100%;
            width: 100%;
            background-color: #00FFFF;
            transition: width 0.2s ease-out;
        }
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 550px;
            text-align: center;
            background-color: rgba(0, 10, 15, 0.9);
            padding: 20px 25px;
            border: 2px solid rgba(0, 255, 255, 0.3); 
            border-radius: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2), 0 0 15px rgba(0, 255, 255, 0.1) inset;
            display: none;
            z-index: 100;
            flex-direction: column;
            align-items: center;
        }
        #message-overlay > p { margin: 5px 0; }
        #main-message-title {
            font-size: clamp(30px, 7vw, 48px);
            font-weight: bold;
            color: #FF00FF;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.6), 0 0 4px #FF00FF;
            margin-bottom: 15px;
        }
        #secondary-message-content {
            font-size: clamp(15px, 3vw, 18px);
            line-height: 1.7;
            color: #00FFFF;
            margin-bottom: 20px;
            white-space: pre-line;
        }
        .final-score-value { 
            font-size: 2em; 
            font-weight: bold;
            color: #FFFFFF;
        }
        #action-button-container { margin-top: 15px; }
        #action-button {
            background: linear-gradient(145deg, #005050, #003030);
            color: #FFFF00; border: 2px solid #FFFF00; border-radius: 8px;
            padding: 12px 25px; font-size: clamp(18px, 4vw, 24px); font-weight: bold;
            cursor: pointer; text-shadow: 0 0 5px #000000;
            box-shadow: 0 0 8px #FFFF00, 0 0 15px #FFFF00 inset;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            display: flex; flex-direction: column; align-items: center;
        }
        #action-button:hover {
            background: linear-gradient(145deg, #007070, #005050);
            box-shadow: 0 0 12px #FFFF00, 0 0 20px #FFFF00 inset, 0 0 5px #FFFFFF;
        }
        #action-button-main-text { display: block; }
        #action-button-subtext { display: block; font-size: clamp(10px, 2vw, 12px); font-weight: normal; color: rgba(255, 255, 0, 0.5); margin-top: 4px; }

        /* Enemy Key Styles */
        #enemy-key {
            margin-top: 25px;
            width: 100%;
            padding: 10px 0;
            border-top: 1px dashed rgba(0, 255, 255, 0.3);
        }
        #enemy-key h3 {
            font-size: 16px;
            color: #00FFFF;
            margin: 5px 0 10px;
            text-align: center;
        }
        .enemy-key-grid {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 10px;
        }
        .enemy-key-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70px;
        }
        .enemy-preview-canvas {
            width: 60px;
            height: 40px;
            margin-bottom: 8px;
            background-color: rgba(0, 10, 20, 0.5);
            border-radius: 4px;
        }
        .enemy-label {
            font-size: 12px;
            color: #00FFFF;
            text-align: center;
        }
        
        .radar-dot { position: absolute; transform: translateY(-50%); }
        .player-dot { width: 6px; height: 16px; background-color: #00FF00; box-shadow: 0 0 3px #00FF00; }
        .human-dot { width: 4px; height: 4px; background-color: #FFFFFF; border-radius: 50%; box-shadow: 0 0 3px #FFFFFF; }
        .enemy-dot { width: 4px; height: 4px; background-color: #FF0000; box-shadow: 0 0 3px #FF0000; }
        .mutant-dot { width: 5px; height: 5px; background-color: #FF8800; animation: pulse 1s infinite; box-shadow: 0 0 4px #FF8800; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #controls-display {
            width: 90%;
            max-width: 800px;
            margin: 10px auto;
            padding: 5px 0;
            text-align: center;
            color: #00AAAA;
            font-size: clamp(11px, 1.8vw, 13px);
            border: 1px solid #005555;
            background-color: rgba(0, 10, 10, 0.5);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        #controls-display span {
            margin: 0 8px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="message-overlay">
            <p id="main-message-title">Defender Ascendant</p>
            <p id="secondary-message-content"></p>
            <div id="action-button-container">
                <button id="action-button">
                    <span id="action-button-main-text">Start</span>
                    <span id="action-button-subtext">Click or press Enter</span>
                </button>
            </div>
            <div id="enemy-key">
                <h3>Enemies</h3>
                <div class="enemy-key-grid">
                    <div class="enemy-key-item">
                        <canvas id="abductor-preview" class="enemy-preview-canvas" width="60" height="40"></canvas>
                        <div class="enemy-label">Abductor</div>
                    </div>
                    <div class="enemy-key-item">
                        <canvas id="mutant-preview" class="enemy-preview-canvas" width="60" height="40"></canvas>
                        <div class="enemy-label">Fighter</div>
                    </div>
                    <div class="enemy-key-item">
                        <canvas id="bomber-preview" class="enemy-preview-canvas" width="60" height="40"></canvas>
                        <div class="enemy-label">Bomber</div>
                    </div>
                    <div class="enemy-key-item">
                        <canvas id="destroyer-preview" class="enemy-preview-canvas" width="60" height="40"></canvas>
                        <div class="enemy-label">Destroyer</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="ui-radar-container">
        <div id="radar"></div>
        <div class="ui-text">
            <div class="score">Score: <span id="score-value">0</span></div>
            <div class="wave">Wave: <span id="wave-value">1</span></div>
            <div>Shield: <span id="shield-bar-container"><span id="shield-fill"></span></span></div>
            <div>Bombs: <span id="bombs-value">3</span></div>
            <div class="lives">Lives: <span id="lives-value">3</span></div>
        </div>
    </div>
    <div id="controls-display">
        <span>Arrows/WASD: Move</span>
        <span>Space/Ctrl: Shoot</span>
        <span>Shift: Shield</span>
        <span>B: Bomb</span>
        <span>H: Hyperspace</span>
    </div>

    <script>
        // --- Game Configuration ---
        const CANVAS_WIDTH = 800; const CANVAS_HEIGHT = 600; const PLANET_WIDTH = CANVAS_WIDTH * 4;
        const GROUND_LEVEL = CANVAS_HEIGHT - 40; const STAR_COUNT = 200;

        // Player
        const PLAYER_WIDTH = 36; const PLAYER_HEIGHT = 18; const PLAYER_THRUST = 0.15;
        const PLAYER_MAX_SPEED = 4.5; const PLAYER_FRICTION = 0.95; const PLAYER_FIRE_RATE = 160; // Increased speed and fire rate
        const PLAYER_PROJECTILE_SPEED = 8; const PLAYER_PROJECTILE_WIDTH = 12; const PLAYER_PROJECTILE_HEIGHT = 4; // Faster projectiles
        const PLAYER_MAX_SHIELD_ENERGY = 100; const PLAYER_SHIELD_DURATION = 2500;
        const PLAYER_SHIELD_RECHARGE_RATE = 2; const PLAYER_SHIELD_ACTIVATION_COST = 35;
        const PLAYER_INVULNERABILITY_DURATION = 2000; const HYPERSPACE_COOLDOWN = 5000;
        const PLAYER_APPEAR_OFFSET = PLAYER_WIDTH * 2;
        const SHIELD_RADIUS_MULTIPLIER = 0.8;
        const SHIELD_MINOR_ENEMY_DESTROY_SCORE = 50;

        // Humanoids & Enemies
        const HUMANOID_COUNT_PER_WAVE_MULTIPLIER = 8; const HUMANOID_WIDTH = 10; const HUMANOID_HEIGHT = 18;
        const HUMANOID_FALL_SPEED = 2.8; const HUMANOID_RESCUE_POINTS = 500; // Faster falling humanoids
        const LANDER_WIDTH = 32; const LANDER_HEIGHT = 24; const LANDER_SPEED = 1.4; const LANDER_POINTS = 150; // Faster Landers
        const MUTANT_WIDTH = 34; const MUTANT_HEIGHT = 26; const MUTANT_SPEED = 1.8; // Faster Mutants
        const MUTANT_FIRE_RATE = 1500; const MUTANT_POINTS = 300;
        
        // Destroyer enemy (appears in level 3+)
        const DESTROYER_WIDTH = 40; const DESTROYER_HEIGHT = 25;
        const DESTROYER_SPEED = 1.4; // Increased speed while maintaining powerful lasers
        const DESTROYER_FIRE_RATE = 2000; // Fires less frequently
        const DESTROYER_POINTS = 350; // Worth more points
        const DESTROYER_LASER_WIDTH = 30; // Long laser beams
        const DESTROYER_LASER_HEIGHT = 2; // Half as tall as before
        const DESTROYER_LASER_SPEED = 9; // Even faster laser beams
        const BOMBER_WIDTH = 50; const BOMBER_HEIGHT = 14; const BOMBER_SPEED = 1.0; // Faster Bombers
        const BOMBER_FIRE_RATE = 2000; const BOMBER_POINTS = 200;
        const BOMBER_BOMB_SPEED = 2.2; const BOMBER_BOMB_WIDTH = 12; const BOMBER_BOMB_HEIGHT = 12; // Faster bombs
        const BOMBER_BOMB_DROP_ACCURACY = 20; // How close (x-axis) bomber needs to be to player to start bombing run
        const BOMBER_TARGET_ALTITUDE_OFFSET = 100; // Desired altitude above player for bombing run
        const BOMB_FUSE_DISTANCE = 150; // Distance bomb travels before exploding
        const WAVE_SPEED_MULTIPLIER = 0.1; // Speed increases by 10% per wave for more challenging progression
        const WAVE_FIRE_RATE_IMPROVEMENT = 0.05; // Fire rate improves by 5% per wave
        const ENEMY_PROJECTILE_SPEED = 3.5; const ENEMY_PROJECTILE_WIDTH = 8; const ENEMY_PROJECTILE_HEIGHT = 8; // Faster enemy projectiles

        // Explosion
        const EXPLOSION_PARTICLE_COUNT = 25; const EXPLOSION_FLASH_MAX_RADIUS = 50;
        const EXPLOSION_FLASH_DURATION = 200; const EXPLOSION_PARTICLE_LIFE = 600;

        // --- Game State Variables ---
        let canvas, ctx;
        let gameRunning = false, gameOverState = false;
        let score = 0, lives = 3, smartBombs = 3, currentWave = 1;
        let worldOffsetX = 0;
        let player = {}, humanoids = [], enemies = [], projectiles = { player: [], enemy: [] }, particles = [], stars = [];
        let keys = {};
        let isFirstEverStart = true;

        let scoreUI, livesUI, bombsUI, shieldFillUI, waveUI, radarDiv;
        let messageOverlay, mainMessageTitle, secondaryMessageContent;
        let actionButton, actionButtonMainText, actionButtonSubtext;

        // --- Audio ---
        let audioInitialized = false;
        let synthPlayerShoot, synthEnemyShoot, synthExplosionNoise, synthExplosionRumbleEnv, synthExplosionClick, synthPlayerHit, synthShieldOn, synthShieldOff, synthHyperspaceEnter, synthHyperspaceExit, synthRescue, synthAbduct, synthWaveClear, synthGameOver, synthGameStart, synthShieldHit;

        function initializeAudio() {
            if (audioInitialized) return Promise.resolve();
            if (Tone.context.state !== 'running') {
                console.log("Audio Context not running, attempting Tone.start()");
                return Tone.start().then(() => {
                    console.log("Tone.start() successful, initializing synths...");
                    if (Tone.Transport.state !== "started") {
                        Tone.Transport.start();
                        console.log("Tone.Transport started.");
                    }

                    synthPlayerShoot = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -18 }).toDestination();
                    synthPlayerShoot.frequency.setValueAtTime("C5", Tone.now());
                    synthPlayerShoot.frequency.linearRampToValueAtTime("C4", Tone.now() + 0.08);

                    synthEnemyShoot = new Tone.PolySynth(Tone.Synth, { polyphony: 4, voice: Tone.Synth, options: { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }, volume: -32 } }).toDestination();

                    const lowOsc = new Tone.Oscillator("C1", "sine").start();
                    synthExplosionRumbleEnv = new Tone.AmplitudeEnvelope({ attack: 0.02, decay: 0.4, sustain: 0.1, release: 0.5 }).toDestination();
                    lowOsc.connect(synthExplosionRumbleEnv); lowOsc.volume.value = -3;

                    // **FIXED HERE: Explosion Noise Synths are single instances**
                    synthExplosionNoise = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.3 }, volume: -10 }).toDestination();
                    synthExplosionClick = new Tone.NoiseSynth({ noise: { type: 'white'}, envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.02}, volume: -18 }).toDestination();


                    synthPlayerHit=new Tone.NoiseSynth({noise:{type:'white'},envelope:{attack:.005,decay:.1,sustain:0,release:.1}}).connect(new Tone.PitchShift({pitch:-12}).toDestination());synthPlayerHit.volume.value=-8;synthShieldOn=new Tone.AMSynth({harmonicity:1.1,oscillator:{type:"sine"},envelope:{attack:.1,decay:.01,sustain:.1,release:.1},modulation:{type:"sine"},modulationEnvelope:{attack:.1,decay:.01,sustain:1,release:.1}}).toDestination();synthShieldOn.volume.value=-12;synthShieldOff=new Tone.AMSynth({harmonicity:1.1,oscillator:{type:"sine"},envelope:{attack:.01,decay:.1,sustain:.01,release:.1},modulation:{type:"sine"},modulationEnvelope:{attack:.01,decay:.1,sustain:1,release:.1}}).toDestination();synthShieldOff.volume.value=-12;synthHyperspaceEnter=new Tone.MonoSynth({oscillator:{type:"sawtooth"},filter:{Q:2,type:"lowpass",rolloff:-24},envelope:{attack:.1,decay:.1,sustain:.3,release:.5},filterEnvelope:{attack:.05,decay:.1,sustain:.1,release:.5,baseFrequency:200,octaves:3}}).toDestination();synthHyperspaceEnter.volume.value=-10;synthHyperspaceExit=new Tone.MonoSynth({oscillator:{type:"square"},filter:{Q:1,type:"bandpass",rolloff:-12},envelope:{attack:.01,decay:.2,sustain:0,release:.1},filterEnvelope:{attack:.01,decay:.1,sustain:0,release:.1,baseFrequency:500,octaves:2}}).toDestination();synthHyperspaceExit.volume.value=-10;synthRescue=new Tone.MetalSynth({frequency:400,envelope:{attack:.001,decay:.2,release:.1},harmonicity:3.1,modulationIndex:16,resonance:4e3,octaves:1.5}).toDestination();synthRescue.volume.value=-8;synthAbduct=new Tone.Synth({oscillator:{type:'triangle'},envelope:{attack:.01,decay:.3,sustain:.1,release:.2}}).toDestination();synthAbduct.volume.value=-15;synthWaveClear=new Tone.PolySynth(Tone.Synth,{oscillator:{type:'pulse',width:.2},envelope:{attack:.01,decay:.1,sustain:.2,release:.2}}).toDestination();synthWaveClear.volume.value=-10;synthGameOver=new Tone.MonoSynth({oscillator:{type:"fatsawtooth",count:3,spread:30},envelope:{attack:.1,decay:.5,sustain:.1,release:1}}).toDestination();synthGameOver.volume.value=-5;synthGameStart=new Tone.PolySynth(Tone.Synth,{oscillator:{type:"triangle8"},envelope:{attack:.02,decay:.2,sustain:.3,release:.4},volume:-8}).toDestination();synthShieldHit=new Tone.MembraneSynth({pitchDecay:.008,octaves:2,envelope:{attack:.001,decay:.2,sustain:0,release:.1}}).toDestination();synthShieldHit.volume.value=-15;

                    audioInitialized = true;
                    console.log("Audio Initialized after Tone.start(). Transport started.");
                }).catch(e => {
                    console.error("Tone.start() failed:", e);
                    return Promise.reject(e); 
                });
            } else {
                 console.log("Audio context already running or initialized.");
                 return Promise.resolve();
            }
        }

        // --- Utility Functions ---
        function random(min, max) { return Math.random() * (max - min) + min; }
        function clamp(value, min, max) { return Math.min(Math.max(value, min), max); }
        function getDistance(x1, y1, x2, y2) { const dx = x1 - x2, dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function worldToCanvasX(worldX) { return worldX - worldOffsetX; }
        function circleRectIntersect(circle, rect) { /* Minified */ const dX=Math.abs(circle.x-rect.x-rect.width/2);const dY=Math.abs(circle.y-rect.y-rect.height/2);if(dX>rect.width/2+circle.radius){return false}if(dY>rect.height/2+circle.radius){return false}if(dX<=rect.width/2){return true}if(dY<=rect.height/2){return true}const dx=dX-rect.width/2;const dy=dY-rect.height/2;return dx*dx+dy*dy<=circle.radius*circle.radius }

        // --- Initialization ---
        window.onload = function() {
            canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
            scoreUI = document.getElementById('score-value'); livesUI = document.getElementById('lives-value');
            bombsUI = document.getElementById('bombs-value'); shieldFillUI = document.getElementById('shield-fill');
            waveUI = document.getElementById('wave-value'); radarDiv = document.getElementById('radar');
            messageOverlay = document.getElementById('message-overlay');
            mainMessageTitle = document.getElementById('main-message-title');
            secondaryMessageContent = document.getElementById('secondary-message-content');
            actionButton = document.getElementById('action-button');
            actionButtonMainText = document.getElementById('action-button-main-text');
            actionButtonSubtext = document.getElementById('action-button-subtext');
            document.addEventListener('keydown', e => { keys[e.code] = true; handleGlobalKeys(e); });
            document.addEventListener('keyup', e => { keys[e.code] = false; });
            actionButton.addEventListener('click', handleActionButtonClick);
            createStars(); showStartScreen(); gameLoop(0);
        };

        function handleActionButtonClick() {
            initializeAudio().then(() => { 
                if (!gameRunning || gameOverState) {
                    let playStartSound = isFirstEverStart || gameOverState;

                    if (gameOverState) { resetGame(); }
                    else if (mainMessageTitle.textContent.includes("Cleared")) { resetGame(true); }
                    else if (isFirstEverStart) { 
                        resetGame();
                    }
                    startGame(playStartSound);
                }
            }).catch(err => {
                 console.error("Cannot start game due to audio init failure:", err);
            });
        }
        function handleGlobalKeys(e) {
            if (e.code === 'Enter') {
                 initializeAudio().then(() => {
                     handleActionButtonClick();
                 }).catch(err => {
                    console.error("Cannot start game via Enter key due to audio init failure:", err);
                 });
            }
        }
        function showStartScreen() {
            mainMessageTitle.textContent="Defender Ascendant";
            secondaryMessageContent.innerHTML=`Save the Humanoids!`;
            actionButtonMainText.textContent="Start";actionButtonSubtext.textContent="Click or press Enter";
            messageOverlay.style.display='flex';gameOverState=false;gameRunning=false;
        }

        function startGame(playStartSound = false) {
            if (!gameRunning) {
                gameRunning = true;
                gameOverState = false;
                messageOverlay.style.display = 'none';
                if (!player.worldX && player.worldX !== 0) {
                    resetGame(); 
                }

                if (audioInitialized && synthGameStart && playStartSound) {
                     const now = Tone.now();
                     // Schedule with Tone.Transport to ensure it plays after context is fully ready
                     Tone.Transport.scheduleOnce(time => {
                        synthGameStart.triggerAttackRelease("C4", "8n", time);
                        synthGameStart.triggerAttackRelease("G4", "8n", time + 0.15);
                        synthGameStart.triggerAttackRelease("C5", "4n", time + 0.3);
                     }, now + 0.05); // Small delay to ensure transport is definitely running
                     isFirstEverStart = false; // Set to false after the first fanfare plays
                }
            }
        }
        function resetGame(isNewWave = false) { /* Minified v2.13 */ if(!isNewWave){score=0;lives=3;smartBombs=3;currentWave=1; isFirstEverStart = true;}player={type:'player',worldX:PLANET_WIDTH/2,y:GROUND_LEVEL-PLAYER_HEIGHT-50,width:PLAYER_WIDTH,height:PLAYER_HEIGHT,vx:0,vy:0,facingDirection:1,color:'#00FF00',shieldEnergy:PLAYER_MAX_SHIELD_ENERGY,isShieldActive:false,shieldActivationTime:0,lastShotTime:0,isInvulnerable:false,invulnerabilityTimer:0,lastHyperspaceTime:0,hyperspaceActive:false};projectiles.player=[];projectiles.enemy=[];enemies=[];humanoids=[];particles=[];worldOffsetX=(player.worldX-CANVAS_WIDTH/2+PLANET_WIDTH)%PLANET_WIDTH;spawnHumanoids();spawnWaveEnemies();updateUI(); }
        function createStars() { /* Minified */ stars=[];for(let i=0;i<STAR_COUNT;i++){stars.push({x:random(0,CANVAS_WIDTH),y:random(0,CANVAS_HEIGHT),size:random(.5,2),parallax:random(.1,.5)})} }
        function spawnHumanoids() { 
            const count = HUMANOID_COUNT_PER_WAVE_MULTIPLIER;
            humanoids = [];
            
            for(let i=0; i<count; i++){
                humanoids.push({
                    type: 'humanoid',
                    worldX: random(0, PLANET_WIDTH),
                    y: GROUND_LEVEL - HUMANOID_HEIGHT,
                    width: HUMANOID_WIDTH,
                    height: HUMANOID_HEIGHT,
                    color: '#FFFFFF',
                    isAbducted: false,
                    abductor: null,
                    isFalling: false,
                    isSafe: true,
                    // Animation properties
                    armAngle: 0,                // Current arm angle
                    armDirection: 1,            // Direction of arm movement (1 or -1)
                    armWaveSpeed: random(0.05, 0.15),  // Speed of arm waving, randomized per humanoid
                    parachuteOpened: false      // Whether parachute is opened
                });
            }
        }
        function spawnWaveEnemies() { 
            /* Enhanced wave spawning with progressive difficulty */ 
            enemies=[]; 
            
            // Spawn Landers - basic enemies that appear in all waves
            const landerCount = 3 + currentWave * 2; 
            for(let i=0; i<landerCount; i++){ 
                enemies.push({
                    type: 'Lander',
                    worldX: random(0, PLANET_WIDTH),
                    y: random(50, CANVAS_HEIGHT/2),
                    width: LANDER_WIDTH,
                    height: LANDER_HEIGHT,
                    vx: 0,
                    vy: 0,
                    color: '#FF0000',
                    targetHuman: null,
                    isCarryingHuman: false,
                    state: 'patrolling',
                    stateTimer: random(1e3, 3e3)
                }); 
            } 
            
            // Spawn Bombers starting from wave 2
            if(currentWave >= 2) { 
                const bomberCount = Math.min(1 + Math.floor((currentWave - 2) / 2), 4); 
                for(let i=0; i<bomberCount; i++){ 
                    enemies.push({
                        type: 'Bomber',
                        worldX: random(0, PLANET_WIDTH),
                        y: random(30, CANVAS_HEIGHT/3),
                        width: BOMBER_WIDTH,
                        height: BOMBER_HEIGHT,
                        vx: 0,
                        vy: 0,
                        color: '#AA0044',
                        state: 'patrolling',
                        stateTimer: random(1e3, 3e3),
                        lastShotTime: 0
                    }); 
                } 
            }
            
            // Spawn Destroyers starting from wave 3
            if(currentWave >= 3) {
                const destroyerCount = Math.min(1 + Math.floor((currentWave - 3) / 2), 3); 
                for(let i=0; i<destroyerCount; i++){
                    enemies.push({
                        type: 'Destroyer',
                        worldX: random(0, PLANET_WIDTH),
                        y: random(40, CANVAS_HEIGHT/4), // Higher up in the sky
                        width: DESTROYER_WIDTH,
                        height: DESTROYER_HEIGHT,
                        vx: 0,
                        vy: 0,
                        color: '#0088FF', // Blue-ish color
                        state: 'patrolling',
                        stateTimer: random(2e3, 5e3),
                        lastShotTime: 0
                    });
                }
            }
        }
        function handleInput() { /* Minified */ if(!gameRunning||gameOverState||player.hyperspaceActive)return;let hInput=0;if(keys['ArrowLeft']||keys['KeyA'])hInput=-1;if(keys['ArrowRight']||keys['KeyD'])hInput=1;if(hInput!==0){player.vx+=PLAYER_THRUST*hInput;player.facingDirection=hInput}if(keys['ArrowUp']||keys['KeyW'])player.vy-=PLAYER_THRUST;if(keys['ArrowDown']||keys['KeyS'])player.vy+=PLAYER_THRUST;if(keys['Space']||keys['ControlLeft']){if(Date.now()-player.lastShotTime>PLAYER_FIRE_RATE){let pSpawnX=player.worldX+(player.facingDirection===1?player.width:-PLAYER_PROJECTILE_WIDTH);let pInitialWorldX = (pSpawnX + PLANET_WIDTH) % PLANET_WIDTH; projectiles.player.push({type:'player_projectile',worldX:pInitialWorldX,y:player.y+player.height/2-PLAYER_PROJECTILE_HEIGHT/2,width:PLAYER_PROJECTILE_WIDTH,height:PLAYER_PROJECTILE_HEIGHT,speed:PLAYER_PROJECTILE_SPEED*player.facingDirection,color:'#FFFF00', spawnWorldX: pInitialWorldX});player.lastShotTime=Date.now();if(audioInitialized&&synthPlayerShoot)synthPlayerShoot.triggerAttackRelease("C5","16n");createParticleEffect(pInitialWorldX,player.y+player.height/2,'#FFA500',3,2,false,50)}}if(keys['KeyB']&&smartBombs>0&&!player.isShieldActive){activateSmartBomb();smartBombs--;keys['KeyB']=false}if((keys['ShiftLeft']||keys['ShiftRight'])&&!player.isShieldActive&&player.shieldEnergy>=PLAYER_SHIELD_ACTIVATION_COST){player.isShieldActive=true;player.shieldEnergy-=PLAYER_SHIELD_ACTIVATION_COST;player.shieldActivationTime=Date.now();keys['ShiftLeft']=keys['ShiftRight']=false;if(audioInitialized&&synthShieldOn)synthShieldOn.triggerAttackRelease("C4",.2)}if(keys['KeyH']&&Date.now()-player.lastHyperspaceTime>HYPERSPACE_COOLDOWN){activateHyperspace();keys['KeyH']=false} }
        function updatePlayer(dt) { /* Minified */ if(player.hyperspaceActive)return;const oldWorldX=player.worldX;player.vx*=PLAYER_FRICTION;player.vy*=PLAYER_FRICTION;player.vx=clamp(player.vx,-PLAYER_MAX_SPEED,PLAYER_MAX_SPEED);player.vy=clamp(player.vy,-PLAYER_MAX_SPEED,PLAYER_MAX_SPEED);let nextRawWorldX=oldWorldX+player.vx;player.y=clamp(player.y+player.vy,0,GROUND_LEVEL-player.height);if(player.vx>0&&nextRawWorldX>=PLANET_WIDTH){player.worldX=nextRawWorldX%PLANET_WIDTH;worldOffsetX=(player.worldX-PLAYER_APPEAR_OFFSET+PLANET_WIDTH)%PLANET_WIDTH}else if(player.vx<0&&nextRawWorldX<0){player.worldX=(nextRawWorldX%PLANET_WIDTH+PLANET_WIDTH)%PLANET_WIDTH;worldOffsetX=(player.worldX-(CANVAS_WIDTH-PLAYER_APPEAR_OFFSET-player.width)+PLANET_WIDTH)%PLANET_WIDTH}else{player.worldX=(nextRawWorldX+PLANET_WIDTH)%PLANET_WIDTH;const screenEdgeBuffer=CANVAS_WIDTH/3.5;const playerCanvasX=(player.worldX-worldOffsetX+PLANET_WIDTH)%PLANET_WIDTH;if(playerCanvasX<screenEdgeBuffer&&player.vx<0){worldOffsetX=(worldOffsetX+player.vx+PLANET_WIDTH)%PLANET_WIDTH}else if(playerCanvasX>CANVAS_WIDTH-screenEdgeBuffer&&player.vx>0){worldOffsetX=(worldOffsetX+player.vx+PLANET_WIDTH)%PLANET_WIDTH}}worldOffsetX=(worldOffsetX+PLANET_WIDTH)%PLANET_WIDTH;if(player.isShieldActive){if(Date.now()-player.shieldActivationTime>PLAYER_SHIELD_DURATION){player.isShieldActive=false;if(audioInitialized&&synthShieldOff)synthShieldOff.triggerAttackRelease("A3",.1);deflectFrozenProjectiles()}}else{player.shieldEnergy=Math.min(PLAYER_MAX_SHIELD_ENERGY,player.shieldEnergy+(PLAYER_SHIELD_RECHARGE_RATE*(dt/1e3)))}if(player.isInvulnerable){player.invulnerabilityTimer-=dt;if(player.invulnerabilityTimer<=0)player.isInvulnerable=false}}
        function updateProjectiles(dt) { 
            // Update player projectiles
            projectiles.player.forEach((p,i)=>{
                if(!p) return;
                p.worldX = (p.worldX + p.speed + PLANET_WIDTH) % PLANET_WIDTH;
                let distTravelled = Math.abs(p.worldX - p.spawnWorldX);
                if(distTravelled > PLANET_WIDTH/2) {
                    distTravelled = PLANET_WIDTH - distTravelled;
                }
                if(distTravelled > CANVAS_WIDTH + 50) {
                    projectiles.player.splice(i, 1);
                }
            });
            
            // Update enemy projectiles
            projectiles.enemy.forEach((p,i)=>{
                if(!p) {
                    projectiles.enemy.splice(i,1);
                    return;
                }
                
                p.worldX = (p.worldX + p.vx + PLANET_WIDTH) % PLANET_WIDTH;
                p.y += p.vy;
                
                // Handle bomb explosions
                if(p.type === 'bomb' && typeof p.startY !== 'undefined') { 
                    const distTravelledY = p.y - p.startY; 
                    if(distTravelledY >= BOMB_FUSE_DISTANCE) { 
                        if(typeof createExplosion === 'function') { 
                            createExplosion(p.worldX + p.width/2, p.y + p.height/2, '#FFA500', 
                                         EXPLOSION_PARTICLE_COUNT, EXPLOSION_FLASH_MAX_RADIUS, 
                                         EXPLOSION_PARTICLE_LIFE, EXPLOSION_FLASH_DURATION, true);
                        }
                        projectiles.enemy.splice(i,1);
                        return;
                    }
                }
                
                // Handle shrapnel distance limit and lifetime
                if(p.type === 'shrapnel') {
                    // Check distance traveled
                    if (p.initialX !== undefined && p.initialY !== undefined && p.maxDistance !== undefined) {
                        const dx = p.worldX - p.initialX;
                        const dy = p.y - p.initialY;
                        const distanceTraveled = Math.sqrt(dx * dx + dy * dy);
                        
                        // Remove if reached max distance
                        if (distanceTraveled >= p.maxDistance) {
                            projectiles.enemy.splice(i, 1);
                            return;
                        }
                    }
                    
                    // Also check lifetime as a backup
                    if (typeof p.life !== 'undefined') {
                        p.life -= dt;
                        if (p.life <= 0) {
                            projectiles.enemy.splice(i, 1);
                            return;
                        }
                    }
                }
                
                // Remove projectiles that go off-screen
                const cX = worldToCanvasX(p.worldX);
                if(cX < -p.width || cX > CANVAS_WIDTH + p.width || 
                   p.y < -p.height || p.y > CANVAS_HEIGHT + p.height) {
                    projectiles.enemy.splice(i,1);
                }
            });
        }
        function updateEnemies(dt) { 
            for(let i=enemies.length-1; i>=0; i--) {
                let e=enemies[i];
                
                if(e.type==='Lander') updateLander(e,dt);
                if(e.type==='Mutant') updateMutant(e,dt);
                if(e.type==='Bomber') updateBomber(e,dt);
                if(e.type==='Destroyer') updateDestroyer(e,dt);
                
                // Apply movement
                e.worldX=(e.worldX+e.vx+PLANET_WIDTH)%PLANET_WIDTH;
                e.y+=e.vy;
            } 
        }
        function updateLander(l, dt) { /* Minified v2.32 */ const waveSpeedMultiplier = 1 + (currentWave - 1) * WAVE_SPEED_MULTIPLIER; l.stateTimer-=dt;switch(l.state){case'patrolling':l.vx=Math.sin(Date.now()*.001+l.worldX*.1)*LANDER_SPEED*.5*waveSpeedMultiplier;l.vy=Math.cos(Date.now()*.0008+l.worldX*.08)*LANDER_SPEED*.3*waveSpeedMultiplier;l.y=clamp(l.y,50,GROUND_LEVEL-l.height-HUMANOID_HEIGHT-20);if(l.stateTimer<=0){l.state='seeking';l.stateTimer=random(2e3,5e3)}break;case'seeking':if(!l.targetHuman||l.targetHuman.isAbducted||!l.targetHuman.isSafe)l.targetHuman=findClosestHuman(l);if(l.targetHuman){let dx=l.targetHuman.worldX-l.worldX;if(Math.abs(dx)>PLANET_WIDTH/2)dx=dx>0?dx-PLANET_WIDTH:dx+PLANET_WIDTH;const ang=Math.atan2(l.targetHuman.y-l.height-l.y,dx);l.vx=Math.cos(ang)*LANDER_SPEED*waveSpeedMultiplier;l.vy=Math.sin(ang)*LANDER_SPEED*waveSpeedMultiplier;if(getDistance(l.worldX,l.y,l.targetHuman.worldX,l.targetHuman.y-l.height)<l.height*1.5){l.state='abducting';l.isCarryingHuman=true;l.targetHuman.isAbducted=true;l.targetHuman.abductor=l;l.targetHuman.isSafe=false;if(audioInitialized&&synthAbduct)synthAbduct.triggerAttackRelease("8n",Tone.now()+.01);}}else{l.state='patrolling';l.stateTimer=random(3e3,6e3)}if(l.stateTimer<=0&&l.state==='seeking'){l.state='patrolling';l.stateTimer=random(3e3,6e3)}break;case'abducting':l.vx=0;l.vy=-LANDER_SPEED*.8*waveSpeedMultiplier;if(l.targetHuman){l.targetHuman.worldX=l.worldX;l.targetHuman.y=l.y+l.height/2}if(l.y<-l.height){if(l.targetHuman){transformToMutant(l.targetHuman,l.worldX,10);let idx=humanoids.indexOf(l.targetHuman);if(idx!==-1)humanoids.splice(idx,1)}enemies.splice(enemies.indexOf(l),1)}break;}}
        function updateMutant(m, dt) { /* Minified v2.26 */ const waveSpeedMultiplier = 1 + (currentWave - 1) * WAVE_SPEED_MULTIPLIER; const waveFireRate = MUTANT_FIRE_RATE * (1 - (currentWave - 1) * WAVE_FIRE_RATE_IMPROVEMENT); const pCX=worldToCanvasX(player.worldX);const mCX=worldToCanvasX(m.worldX);let dxToPlayer=player.worldX-m.worldX;if(Math.abs(dxToPlayer)>PLANET_WIDTH/2){dxToPlayer=dxToPlayer>0?dxToPlayer-PLANET_WIDTH:dxToPlayer+PLANET_WIDTH}const dyToPlayer=player.y-m.y;const ang=Math.atan2(dyToPlayer,dxToPlayer);m.vx=Math.cos(ang)*MUTANT_SPEED*waveSpeedMultiplier;m.vy=Math.sin(ang)*MUTANT_SPEED*waveSpeedMultiplier;if(Date.now()-(m.lastShotTime||0)>waveFireRate){projectiles.enemy.push({type:'enemy_projectile',worldX:m.worldX+m.width/2,y:m.y+m.height/2,vx:Math.cos(ang)*ENEMY_PROJECTILE_SPEED,vy:Math.sin(ang)*ENEMY_PROJECTILE_SPEED,width:ENEMY_PROJECTILE_WIDTH,height:ENEMY_PROJECTILE_HEIGHT,color:'#FF8800'});m.lastShotTime=Date.now();if(audioInitialized&&synthEnemyShoot)synthEnemyShoot.triggerAttackRelease("A3","8n")}}
        function updateDestroyer(d, dt) {
            // Ensure initialization of state if not already done
            if (!d.state) {
                d.state = 'patrolling';
                d.stateTimer = random(2000, 4000);
                d.lastShotTime = Date.now();
            }
            
            // Apply wave-based difficulty scaling
            const waveSpeedMultiplier = 1 + (currentWave - 1) * WAVE_SPEED_MULTIPLIER;
            const waveFireRate = DESTROYER_FIRE_RATE * (1 - (currentWave - 1) * WAVE_FIRE_RATE_IMPROVEMENT);
            
            // Decrease state timer
            d.stateTimer -= dt;
            
            // Hornet-like movement: much more vertical than horizontal (bobbing up and down)
            switch(d.state) {
                case 'patrolling':
                    // Primarily vertical motion (hornet bobbing) with minimal horizontal movement
                    // Use a smaller coefficient for horizontal movement and larger for vertical
                    d.vx = Math.cos(Date.now() * 0.0005 + d.worldX * 0.03) * DESTROYER_SPEED * 0.3 * waveSpeedMultiplier;
                    d.vy = Math.sin(Date.now() * 0.003 + d.worldX * 0.05) * DESTROYER_SPEED * 1.2 * waveSpeedMultiplier;
                    
                    // Keep within reasonable height bounds
                    d.y = clamp(d.y, 30, CANVAS_HEIGHT / 2);
                    
                    // Occasionally switch to targeting state
                    if (d.stateTimer <= 0) {
                        d.state = 'targeting';
                        d.stateTimer = random(1500, 2500); // Shorter targeting time
                    }
                    
                    // Periodically fire even in patrol mode
                    if (Date.now() - (d.lastShotTime || 0) > waveFireRate * 1.5) {
                        fireLaser(d);
                    }
                    
                    break;
                    
                case 'targeting':
                    // Calculate angle to player for targeting
                    let dxToPlayer = player.worldX - d.worldX;
                    if (Math.abs(dxToPlayer) > PLANET_WIDTH / 2) {
                        dxToPlayer = dxToPlayer > 0 ? dxToPlayer - PLANET_WIDTH : dxToPlayer + PLANET_WIDTH;
                    }
                    const dyToPlayer = player.y - d.y;
                    
                    // Move towards player's position but with more vertical variance (hornet-like)
                    const angleToPlayer = Math.atan2(dyToPlayer, dxToPlayer);
                    d.vx = Math.cos(angleToPlayer) * DESTROYER_SPEED * 0.4 * waveSpeedMultiplier;
                    d.vy = Math.sin(angleToPlayer) * DESTROYER_SPEED * 0.7 * waveSpeedMultiplier;
                    
                    // Add pronounced vertical bobbing movement to make it more hornet-like
                    d.vy += Math.sin(Date.now() * 0.006) * DESTROYER_SPEED * 0.6 * waveSpeedMultiplier;
                    
                    // Fire laser beam when cooldown complete
                    if (Date.now() - (d.lastShotTime || 0) > waveFireRate) {
                        fireLaser(d);
                    }
                    
                    // Switch back to patrolling after a while
                    if (d.stateTimer <= 0) {
                        d.state = 'patrolling';
                        d.stateTimer = random(2000, 4000);
                    }
                    break;
            }
        }
        
        // Helper function to fire laser from Destroyer
        function fireLaser(d) {
            // Center position for both lasers
            const laserX = d.worldX + d.width / 2 - DESTROYER_LASER_WIDTH / 2;
            
            // Create downward laser beam
            projectiles.enemy.push({
                type: 'laser',
                worldX: laserX,
                y: d.y + d.height,  // Position at bottom of ship
                vx: 0,  // Laser goes straight down
                vy: DESTROYER_LASER_SPEED,  // Positive velocity for downward movement
                width: DESTROYER_LASER_WIDTH,
                height: DESTROYER_LASER_HEIGHT,
                color: '#FF0000' // Red laser beam
            });
            
            // Create upward laser beam
            projectiles.enemy.push({
                type: 'laser',
                worldX: laserX,
                y: d.y - DESTROYER_LASER_HEIGHT,  // Position at top of ship
                vx: 0,  // Laser goes straight up
                vy: -DESTROYER_LASER_SPEED,  // Negative velocity for upward movement
                width: DESTROYER_LASER_WIDTH,
                height: DESTROYER_LASER_HEIGHT,
                color: '#FF0000' // Red laser beam
            });
            
            d.lastShotTime = Date.now();
            
            // Play laser sound
            if (audioInitialized && synthEnemyShoot) {
                synthEnemyShoot.triggerAttackRelease("E4", "16n");
            }
        }
        
        function updateBomber(b, dt) { /* Bomber alien - improved AI */
            const waveSpeedMultiplier = 1 + (currentWave - 1) * WAVE_SPEED_MULTIPLIER;
            const effectiveBomberSpeed = BOMBER_SPEED * waveSpeedMultiplier;
            const waveFireRate = BOMBER_FIRE_RATE * (1 - (currentWave - 1) * WAVE_FIRE_RATE_IMPROVEMENT);

            b.stateTimer -= dt;

            // Common behavior: maintain altitude constraints
            b.y = clamp(b.y, 30, CANVAS_HEIGHT / 2.5); // Keep bombers in the upper part of the screen

            switch(b.state) {
                case 'patrolling':
                    if (typeof b.patrolDirection === 'undefined' || b.stateTimer <= 0) {
                        b.patrolDirection = (Math.random() < 0.5 ? -1 : 1); // Pick a random direction
                        b.stateTimer = random(3000, 5000); // Patrol in this direction for a while
                        b.vx = b.patrolDirection * effectiveBomberSpeed * 0.7;
                    }
                    // If near edge of patrol zone (e.g., 1/4 to 3/4 of screen for variety), consider changing direction
                    // This is a simple patrol, could be made more complex
                    if ((b.patrolDirection === -1 && b.worldX < PLANET_WIDTH / 4) || 
                        (b.patrolDirection === 1 && b.worldX > PLANET_WIDTH * 3 / 4)) {
                        b.patrolDirection *= -1;
                        b.vx = b.patrolDirection * effectiveBomberSpeed * 0.7;
                    }
                    b.vy = Math.sin(Date.now() * 0.0003 + b.worldX * 0.02) * effectiveBomberSpeed * 0.2; // Gentle vertical oscillation

                    // Chance to switch to targeting
                    if (random(0, 100) < 2 && b.stateTimer > 1000) { // Small chance to switch early if conditions met
                         // Check if player is somewhat underneath
                        const dxToPlayer = player.worldX - b.worldX;
                        if (Math.abs(dxToPlayer) < CANVAS_WIDTH / 2) {
                            b.state = 'targeting';
                            b.stateTimer = random(2000, 4000); // Time to target
                        }
                    } else if (b.stateTimer <=0) {
                        b.state = 'targeting';
                        b.stateTimer = random(2000, 4000); // Time to target
                    }
                    break;

                case 'targeting':
                    const dxToPlayer = player.worldX - b.worldX;
                    const targetY = Math.max(30, player.y - BOMBER_TARGET_ALTITUDE_OFFSET); // Ensure targetY is valid
                    const dyToTarget = targetY - b.y;

                    if (Math.abs(dxToPlayer) > 20) { 
                        b.vx = Math.sign(dxToPlayer) * effectiveBomberSpeed * 0.8;
                    } else {
                        b.vx *= 0.8; // Slow down when aligned horizontally
                    }

                    if (Math.abs(dyToTarget) > 10) { // Tolerance for vertical alignment
                        b.vy = Math.sign(dyToTarget) * effectiveBomberSpeed * 0.4; // Vertical speed
                    } else {
                        b.vy = 0; // Maintain altitude once vertically aligned
                    }

                    if (b.stateTimer <= 0 || (Math.abs(dxToPlayer) <= BOMBER_BOMB_DROP_ACCURACY && Math.abs(dyToTarget) <= 20)) {
                        b.state = 'bombing';
                        b.stateTimer = random(1500, 2500); // Duration of bombing run
                        b.vx = (b.patrolDirection || (player.worldX > b.worldX ? 1: -1)) * effectiveBomberSpeed * 0.3; // Slow down, use patrol or player direction
                        b.vy = 0; // Stop vertical movement for bombing run
                    }
                    break;

                case 'bombing':
                    // Slight descent during bombing run (or maintain altitude)
                    // b.vy = effectiveBomberSpeed * 0.1; // Original descent, can be removed if preferred
                    
                    if (Date.now() - (b.lastShotTime || 0) > waveFireRate) {
                        projectiles.enemy.push({
                            type: 'bomb',
                            worldX: b.worldX + b.width / 2 - BOMBER_BOMB_WIDTH / 2,
                            y: b.y + b.height,
                            startY: b.y + b.height, // Store initial Y for fuse logic
                            vx: 0, // Bombs fall straight down relative to bomber's movement
                            vy: BOMBER_BOMB_SPEED,
                            width: BOMBER_BOMB_WIDTH,
                            height: BOMBER_BOMB_HEIGHT,
                            color: '#FF4444'
                        });
                        b.lastShotTime = Date.now();
                        if (audioInitialized && synthEnemyShoot) synthEnemyShoot.triggerAttackRelease("G3", "8n");
                    }

                    if (b.stateTimer <= 0) {
                        b.state = 'patrolling';
                        b.patrolDirection = undefined; // Reset patrol direction for next patrol cycle
                        b.stateTimer = random(3000, 6000);
                    }
                    break;
            }
        }
        function findClosestHuman(e){ /* Minified */ let c=null,mD=Infinity;humanoids.forEach(h=>{if(!h.isAbducted&&h.isSafe){let dX=Math.abs(h.worldX-e.worldX);let dist=Math.min(dX,PLANET_WIDTH-dX);if(dist<mD){mD=dist;c=h;}}});return c;}
        function transformToMutant(human,x,y){ /* Minified */ enemies.push({type:'Mutant',worldX:x,y:y,width:MUTANT_WIDTH,height:MUTANT_HEIGHT,vx:0,vy:0,color:'#FF6347',lastShotTime:0});createExplosion(x,y,'#FF6347');}
        function updateHumanoids(dt){ 
            humanoids.forEach(h => {
                // Handle falling humanoids
                if(h.isFalling) {
                    // Open the parachute as soon as they start falling
                    if (!h.parachuteOpened) {
                        h.parachuteOpened = true;
                    }
                    
                    // Fall at a slower speed when parachute is open
                    h.y += HUMANOID_FALL_SPEED;
                    
                    // Animate arm waving while falling
                    h.armAngle += h.armWaveSpeed * h.armDirection * (dt / 30);
                    
                    // Change arm direction when reaching limits
                    if (Math.abs(h.armAngle) > 0.5) {
                        h.armDirection *= -1;
                    }
                    
                    // Land safely on the ground
                    if (h.y >= GROUND_LEVEL - h.height) {
                        h.y = GROUND_LEVEL - h.height;
                        h.isFalling = false;
                        h.isSafe = true;
                        h.parachuteOpened = false;
                        h.armAngle = 0; // Reset arm position
                    }
                } else if (h.isAbducted) {
                    // When abducted, wave arms more frantically
                    h.armAngle += h.armWaveSpeed * 1.5 * h.armDirection * (dt / 30);
                    
                    // Change direction more frequently
                    if (Math.abs(h.armAngle) > 0.3) {
                        h.armDirection *= -1;
                    }
                }
            });
        }
        function updateParticles(dt){ /* Minified */ for(let i=particles.length-1;i>=0;i--){let p=particles[i];p.life-=dt;if(p.life<=0){particles.splice(i,1);continue;}if(p.type==='explosion_flash'){p.radius=p.maxRadius*(1-(p.life/p.initialLife));p.alpha=0.8*(p.life/p.initialLife);}else{p.vy+=0.05;p.vx*=0.99;if(typeof p.worldX !=='undefined'){p.worldX=(p.worldX+p.vx+PLANET_WIDTH)%PLANET_WIDTH;}else{p.x+=p.vx;}p.y+=p.vy;p.alpha=p.life/p.initialLife;}}}
        function createParticleEffect(x,y,color,count,speedRange,isScreenSpace=false, life = EXPLOSION_PARTICLE_LIFE, particleType = 'debris'){ /* Minified */ for(let i=0;i<count;i++){let p={y:y,vx:random(-speedRange,speedRange),vy:random(-speedRange-1,speedRange-3),size:random(1,4),color:color,life:random(life*0.5,life),initialLife:life, alpha:1.0, type: particleType};if(isScreenSpace){p.x=x;}else{p.worldX=x;}particles.push(p);}}
        function createExplosion(worldX, y, baseColor, particleCount = EXPLOSION_PARTICLE_COUNT, flashRadius = EXPLOSION_FLASH_MAX_RADIUS, particleLife = EXPLOSION_PARTICLE_LIFE, flashDuration = EXPLOSION_FLASH_DURATION, createShrapnel = false) {
            // Sound effects
            if(audioInitialized) {
                Tone.Transport.scheduleOnce(time=>{
                    if(synthExplosionClick)synthExplosionClick.triggerAttackRelease("32n",time)
                },Tone.now()+.001);
                Tone.Transport.scheduleOnce(time=>{
                    if(synthExplosionNoise)synthExplosionNoise.triggerAttackRelease("8n",time)
                },Tone.now()+.006);
                Tone.Transport.scheduleOnce(time=>{
                    if(synthExplosionRumbleEnv)synthExplosionRumbleEnv.triggerAttackRelease(.5,time)
                },Tone.now()+.011);
            }
            
            // Flash effect
            particles.push({
                type: 'explosion_flash',
                worldX: worldX,
                y: y,
                radius: 0,
                maxRadius: flashRadius,
                color: 'rgba(255,255,200,0.9)',
                life: flashDuration,
                initialLife: flashDuration,
                alpha: 0.9
            });
            
            // Visual debris particles
            const colors = [baseColor, '#FFA500', '#FF4500', '#FFD700'];
            for(let i=0; i<particleCount; i++) {
                particles.push({
                    type: 'debris',
                    worldX: worldX,
                    y: y,
                    vx: random(-5,5),
                    vy: random(-6,1),
                    size: random(2,5),
                    color: colors[Math.floor(random(0,colors.length))],
                    life: random(particleLife*.7, particleLife),
                    initialLife: particleLife,
                    alpha: 1.0
                });
            }
            
            // Create damaging shrapnel if this is a bomb explosion
            if(createShrapnel) {
                const SHRAPNEL_COUNT = 8; // 8 dots in all directions
                const SHRAPNEL_SPEED = 4; // Faster speed
                const SHRAPNEL_SIZE = 8; // Larger, more visible dots
                const SHRAPNEL_MAX_DISTANCE = 200; // Distance to travel before disappearing
                
                // Create shrapnel in all directions
                for(let i=0; i<SHRAPNEL_COUNT; i++) {
                    const angle = (i / SHRAPNEL_COUNT) * Math.PI * 2;
                    const vx = Math.cos(angle) * SHRAPNEL_SPEED;
                    const vy = Math.sin(angle) * SHRAPNEL_SPEED;
                    
                    projectiles.enemy.push({
                        type: 'shrapnel',
                        worldX: worldX,
                        y: y,
                        width: SHRAPNEL_SIZE,
                        height: SHRAPNEL_SIZE,
                        vx: vx,
                        vy: vy,
                        color: '#FF0000', // Bright red for better visibility
                        life: 500, // Longer lifetime 
                        initialX: worldX, // Store initial position to track distance
                        initialY: y,
                        maxDistance: SHRAPNEL_MAX_DISTANCE // Max distance to travel
                    });
                }
            }
        }

        function collisionDetection(){ /* Minified v2.17 */ if(!gameRunning||gameOverState||player.hyperspaceActive)return;const pCX=worldToCanvasX(player.worldX);const pRect={x:pCX,y:player.y,width:player.width,height:player.height};const shieldRadius=player.width*SHIELD_RADIUS_MULTIPLIER;const shieldCircle={x:pCX+player.width/2,y:player.y+player.height/2,radius:shieldRadius};for(let i=projectiles.player.length-1;i>=0;i--){let p=projectiles.player[i];if(!p)continue;const pR={x:worldToCanvasX(p.worldX),y:p.y,width:p.width,height:p.height};for(let j=enemies.length-1;j>=0;j--){let e=enemies[j];if(!e)continue;const eR={x:worldToCanvasX(e.worldX),y:e.y,width:e.width,height:e.height};if(rectIntersect(pR,eR)){createExplosion(e.worldX,e.y+e.height/2,e.color);score+=(e.type==='Lander'?LANDER_POINTS:(e.type==='Bomber'?BOMBER_POINTS:MUTANT_POINTS));projectiles.player.splice(i,1);if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}enemies.splice(j,1);break}}}for(let i=projectiles.enemy.length-1;i>=0;i--){let p=projectiles.enemy[i];if(!p)continue;const pR={x:worldToCanvasX(p.worldX),y:p.y,width:p.width,height:p.height};if(player.isShieldActive&&circleRectIntersect(shieldCircle,pR)){createParticleEffect(p.worldX,p.y,'#00FFFF',5,2,false,100,'shield_hit');if(audioInitialized&&synthShieldHit)synthShieldHit.triggerAttackRelease("C5","16n");projectiles.enemy.splice(i,1)}else if(!player.isInvulnerable&&rectIntersect(pR,pRect)){projectiles.enemy.splice(i,1);playerHit();break}}for(let i=enemies.length-1;i>=0;i--){let e=enemies[i];if(!e)continue;const eR={x:worldToCanvasX(e.worldX),y:e.y,width:e.width,height:e.height};if(player.isShieldActive&&circleRectIntersect(shieldCircle,eR)){if(e.type==='Lander'||e.type==='Bomber'){createExplosion(e.worldX,e.y+e.height/2,e.color);score+=SHIELD_MINOR_ENEMY_DESTROY_SCORE;if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}enemies.splice(i,1);if(audioInitialized&&synthShieldHit)synthShieldHit.triggerAttackRelease("A4","16n")}else{createParticleEffect(e.worldX,e.y,'#00FFFF',8,3,false,150,'shield_hit');if(audioInitialized&&synthShieldHit)synthShieldHit.triggerAttackRelease("E4","16n")}}else if(!player.isInvulnerable&&rectIntersect(pRect,eR)){if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}playerHit();enemies.splice(i,1);break}}for(let i=humanoids.length-1;i>=0;i--){let h=humanoids[i];if(!h)continue;if(h.isFalling){const hR={x:worldToCanvasX(h.worldX),y:h.y,width:h.width,height:h.height};if(rectIntersect(pRect,hR)){h.isFalling=false;h.y=GROUND_LEVEL-h.height;h.isSafe=true;score+=HUMANOID_RESCUE_POINTS;if(audioInitialized&&synthRescue)synthRescue.triggerAttackRelease("A5","8n");createParticleEffect(player.worldX,player.y,'#00FF00',10,3,false,200,'rescue_flash')}}}}
        function rectIntersect(r1,r2){ /* Minified */ return!(r2.x>r1.x+r1.width||r2.x+r2.width<r1.x||r2.y>r1.y+r1.height||r2.y+r2.height<r1.y);}
        function activateSmartBomb(){ /* Minified */ if(audioInitialized&&synthExplosionNoise)synthExplosionNoise.triggerAttackRelease(.5); /* Use noise for smart bomb */ createExplosion(worldOffsetX+CANVAS_WIDTH/2,CANVAS_HEIGHT/2,'#FFFFFF');for(let i=enemies.length-1;i>=0;i--){let e=enemies[i];const eCX=worldToCanvasX(e.worldX);if(eCX>-e.width&&eCX<CANVAS_WIDTH&&e.y>-e.height&&e.y<CANVAS_HEIGHT){if(e.type !=='Mutant'){createExplosion(e.worldX,e.y+e.height/2,e.color)}else{createParticleEffect(e.worldX,e.y+e.height/2,e.color,15,4)}if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}enemies.splice(i,1);score+=50}}}
        function deflectFrozenProjectiles(){}
        function activateHyperspace(){ /* Minified */ if(audioInitialized&&synthHyperspaceEnter)synthHyperspaceEnter.triggerAttackRelease("C2",.7);player.lastHyperspaceTime=Date.now();player.hyperspaceActive=true;createParticleEffect(player.worldX,player.y+player.height/2,'#FFFFFF',50,8,false,300,'hyperspace_trail');setTimeout(()=>{player.worldX=random(0,PLANET_WIDTH);player.y=random(CANVAS_HEIGHT*.2,GROUND_LEVEL-player.height-50);player.vx=0;player.vy=0;worldOffsetX=(player.worldX-CANVAS_WIDTH/2+PLANET_WIDTH)%PLANET_WIDTH;player.hyperspaceActive=false;player.isInvulnerable=true;player.invulnerabilityTimer=1e3;if(audioInitialized&&synthHyperspaceExit)synthHyperspaceExit.triggerAttackRelease("G5",.2);createParticleEffect(player.worldX,player.y+player.height/2,'#FFFFFF',30,5,false,300,'hyperspace_arrival')},750)}
        function playerHit(){ /* Minified */ if(player.isInvulnerable||player.hyperspaceActive)return;lives--;if(audioInitialized&&synthPlayerHit)synthPlayerHit.triggerAttackRelease(.1);createExplosion(player.worldX,player.y+player.height/2,player.color);if(lives<=0){triggerGameOver()}else{player.worldX=(worldOffsetX+CANVAS_WIDTH/2+PLANET_WIDTH)%PLANET_WIDTH;player.y=GROUND_LEVEL-PLAYER_HEIGHT-50;player.vx=0;player.vy=0;player.isInvulnerable=true;player.invulnerabilityTimer=PLAYER_INVULNERABILITY_DURATION;player.shieldEnergy=PLAYER_MAX_SHIELD_ENERGY;player.isShieldActive=false}}
        function triggerGameOver(){
            gameRunning=false;gameOverState=true;
            if(audioInitialized&&synthGameOver)synthGameOver.triggerAttackRelease("C2",1.5);
            mainMessageTitle.textContent="Game Over!";
            secondaryMessageContent.innerHTML=`Final Score: <span class="final-score-value">${score}</span>`; 
            actionButtonMainText.textContent="Restart";
            actionButtonSubtext.textContent="Click or press Enter";
            messageOverlay.style.display='flex';
        }
        function checkWaveCompletion(){ 
            // Count all hostile enemy types including the new Destroyer
            const activeHostiles = enemies.filter(e => 
                e.type === 'Lander' || 
                e.type === 'Mutant' || 
                e.type === 'Bomber' || 
                e.type === 'Destroyer'
            ).length;
            
            if (gameRunning && !gameOverState && activeHostiles === 0 && humanoids.length > 0) {
                // Wave cleared
                gameRunning = false;
                currentWave++;
                score += humanoids.length * 100;
                
                if (audioInitialized && synthWaveClear) {
                    synthWaveClear.triggerAttackRelease(["C4", "E4", "G4"], "8n", "+0.1");
                }
                
                mainMessageTitle.textContent = `Wave ${currentWave-1} Cleared!`;
                secondaryMessageContent.textContent = `Humanoid Bonus: ${humanoids.length*100} points!`;
                actionButtonMainText.textContent = "Next Wave";
                actionButtonSubtext.textContent = "Click or press Enter";
                messageOverlay.style.display = 'flex';
            } else if (gameRunning && !gameOverState && humanoids.length === 0 && activeHostiles > 0) {
                // All humanoids lost
                triggerGameOver();
                mainMessageTitle.textContent = "Planet Lost!";
                secondaryMessageContent.innerHTML = `All humanoids abducted. Final Score: <span class="final-score-value">${score}</span>`;
            }
        }
        function draw(){ /* Minified */ if(!ctx)return;ctx.fillStyle='#000510';ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);stars.forEach(s=>{const sX=(s.x-(worldOffsetX*s.parallax)%CANVAS_WIDTH+CANVAS_WIDTH)%CANVAS_WIDTH;ctx.fillStyle=`rgba(200,220,255,${Math.max(.3,s.size/1.5*.8)})`;ctx.fillRect(sX,s.y,s.size,s.size)});ctx.strokeStyle='#0088AA';ctx.lineWidth=1.5;for(let j=0;j<3;j++){ctx.beginPath();let pF=.2+j*.2,a=15+j*10,f=.01+j*.005;for(let x=0;x<CANVAS_WIDTH;x++){let wX=x+worldOffsetX*pF,tY=GROUND_LEVEL+10+j*10+Math.sin(wX*f)*a;if(x===0)ctx.moveTo(x,tY);else ctx.lineTo(x,tY)}ctx.globalAlpha=.3+j*.2;ctx.stroke()}ctx.globalAlpha=1;humanoids.forEach(h=>drawWrappedEntity(ctx,h));projectiles.player.forEach(p=>drawWrappedEntity(ctx,p));projectiles.enemy.forEach(p=>drawWrappedEntity(ctx,p));enemies.forEach(e=>drawWrappedEntity(ctx,e));if(!player.hyperspaceActive&&player.worldX!==undefined){ctx.globalAlpha=(player.isInvulnerable&&Math.floor(player.invulnerabilityTimer/100)%2===0)?.5:1;drawWrappedEntity(ctx,player);if(player.isShieldActive){const pCX=worldToCanvasX(player.worldX);ctx.strokeStyle='#00FFFF';ctx.lineWidth=2;ctx.beginPath();ctx.arc(pCX+player.width/2,player.y+player.height/2,player.width*SHIELD_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.stroke();ctx.fillStyle='rgba(0,255,255,0.1)';ctx.fill()}ctx.globalAlpha=1}particles.forEach(p=>{ctx.globalAlpha=p.alpha;let pCX=typeof p.worldX !=='undefined'?worldToCanvasX(p.worldX):p.x;if(p.type==='explosion_flash'){ctx.beginPath();ctx.arc(pCX,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color;ctx.fill()}else{ctx.fillStyle=p.color;ctx.fillRect(pCX,p.y,p.size,p.size)}});ctx.globalAlpha=1;drawRadar()}
        function drawWrappedEntity(ctx, entity) { /* Minified */ if(!entity||typeof entity.worldX==='undefined'||typeof entity.y==='undefined'||typeof entity.width==='undefined'||typeof entity.height==='undefined'){return}const canvasX=worldToCanvasX(entity.worldX);drawSpecificEntity(ctx,entity,canvasX,entity.y);if(canvasX<entity.width+20){drawSpecificEntity(ctx,entity,canvasX+PLANET_WIDTH,entity.y)}if(canvasX+entity.width>CANVAS_WIDTH-20){drawSpecificEntity(ctx,entity,canvasX-PLANET_WIDTH,entity.y)}}
        function drawSpecificEntity(eCtx,e,cX,cY){ /* Minified */ if(cX+e.width<0||cX>CANVAS_WIDTH||cY+e.height<0||cY>CANVAS_HEIGHT){return}eCtx.fillStyle=e.color;eCtx.strokeStyle=e.color;eCtx.lineWidth=1.5;switch(e.type){case'player':
            // Draw the main triangular ship body
            eCtx.beginPath();
            
            if(player.facingDirection === 1) {
                // Ship facing right
                eCtx.moveTo(cX, cY);
                eCtx.lineTo(cX + e.width, cY + e.height/2);
                eCtx.lineTo(cX, cY + e.height);
            } else {
                // Ship facing left
                eCtx.moveTo(cX + e.width, cY);
                eCtx.lineTo(cX, cY + e.height/2);
                eCtx.lineTo(cX + e.width, cY + e.height);
            }
            
            eCtx.closePath();
            eCtx.fill();
            
            // Draw a simple circle dome positioned halfway along the slope
            eCtx.beginPath();
            eCtx.strokeStyle = e.color;
            eCtx.lineWidth = 1.5;
            
            // Calculate the position halfway along the slope
            // For both directions, we need to find a point halfway along the top slope
            const domeRadius = e.width * 0.15; // Small circle
            let domeX, domeY;
            
            if (player.facingDirection === 1) { // Right-facing ship
                // For right-facing, the slope goes from top-left to top-right
                // Find the midpoint of that slope
                domeX = cX + e.width * 0.5; // Halfway along width
                domeY = cY + e.height * 0.25; // Quarter way down height
            } else { // Left-facing ship
                // For left-facing, the slope goes from top-right to top-left
                // Find the midpoint of that slope
                domeX = cX + e.width * 0.5; // Halfway along width
                domeY = cY + e.height * 0.25; // Quarter way down height
            }
            
            // Draw a full circle
            eCtx.arc(domeX, domeY, domeRadius, 0, Math.PI * 2, false);
            eCtx.stroke();
            
            // Draw thruster flame indicators when moving
            let tAH = false, tS = 'none';
            if(keys['ArrowLeft'] || keys['KeyA']) {
                tAH = true;
                tS = 'right';
            } else if(keys['ArrowRight'] || keys['KeyD']) {
                tAH = true;
                tS = 'left';
            }
            
            if(tAH) {
                eCtx.fillStyle = '#FFA500';
                let tX = tS === 'left' ? cX - 5 : cX + e.width;
                eCtx.fillRect(tX, cY + e.height/4, 5, e.height/2);
            }
            
            if(keys['ArrowUp'] || keys['KeyW']) {
                eCtx.fillStyle = '#FFA500';
                eCtx.fillRect(cX + e.width/2 - 2.5, cY + e.height, 5, 5);
            } else if(keys['ArrowDown'] || keys['KeyS']) {
                eCtx.fillStyle = '#FFA500';
                eCtx.fillRect(cX + e.width/2 - 2.5, cY - 5, 5, 5);
            }
            break;case'Lander':
            // Jellyfish-like Abductor (dome top with tentacles)
            // Draw the dome top (with increased thickness)
            eCtx.beginPath();
            eCtx.ellipse(cX + e.width/2, cY + e.height*0.45, e.width/2, e.height*0.45, 0, Math.PI, 0);
            eCtx.fill();
            
            // Draw the tentacles with direct center positioning
            const tentacleCount = 5;
            const tentacleWidth = 1; // Keep tentacles thin
            const tentacleSpacing = 6; // Fixed spacing between tentacles
            const totalWidth = (tentacleCount - 1) * tentacleSpacing;
            const tentacleStartY = cY + e.height * 0.4;
            const tentacleLength = e.height * 0.6;
            
            // Explicitly center the tentacles under the dome
            const centerOfDome = cX + e.width / 2;
            const startX = centerOfDome - totalWidth / 2;
            
            // Apply a tiny rightward offset to fix the visual balance
            const rightwardOffset = e.width * 0.02; // 2% of width to the right
            
            for (let i = 0; i < tentacleCount; i++) {
                // Calculate x position with explicit centering
                const tentacleX = startX + (tentacleSpacing * i) + rightwardOffset;
                
                eCtx.beginPath();
                eCtx.moveTo(tentacleX, tentacleStartY);
                
                // Create a wavy tentacle effect
                const segments = 3;
                const segmentHeight = tentacleLength / segments;
                const waveAmplitude = tentacleWidth * 0.7;
                
                for (let j = 1; j <= segments; j++) {
                    const waveX = tentacleX + (j % 2 === 0 ? waveAmplitude : -waveAmplitude);
                    const waveY = tentacleStartY + segmentHeight * j;
                    eCtx.lineTo(waveX, waveY);
                }
                
                eCtx.stroke();
            }
            break;case'Mutant':
            // Fighter with flat top and dome
            eCtx.fillStyle = e.color;
            
            // Main body - flat-topped pentagon
            eCtx.beginPath();
            const flatTopY = cY + e.height * 0.3; // Cut off top 1/3 and make flat
            const flatTopWidth = e.width * 0.4; // Width of the flat top
            
            eCtx.moveTo(cX + (e.width - flatTopWidth)/2, flatTopY); // Left point of flat top
            eCtx.lineTo(cX + (e.width + flatTopWidth)/2, flatTopY); // Right point of flat top
            eCtx.lineTo(cX + e.width, cY + e.height * 0.7); // Right point
            eCtx.lineTo(cX + e.width * 0.7, cY + e.height); // Bottom right
            eCtx.lineTo(cX + e.width * 0.3, cY + e.height); // Bottom left
            eCtx.lineTo(cX, cY + e.height * 0.7); // Left point
            eCtx.closePath();
            eCtx.fill();
            
            // Draw the dome (half circle) on top
            eCtx.beginPath();
            eCtx.strokeStyle = e.color;
            eCtx.lineWidth = 1.5;
            const centerX = cX + e.width/2;
            const radius = flatTopWidth/2;
            eCtx.arc(centerX, flatTopY, radius, Math.PI, 0, false); // Half circle, open at bottom
            eCtx.stroke();
            break;case'Destroyer':
            // Save the current state
            eCtx.save();
            
            // Reset all properties that could be causing artifacts
            eCtx.globalAlpha = 1.0;
            eCtx.globalCompositeOperation = 'source-over';
            eCtx.shadowBlur = 0;
            eCtx.shadowColor = 'transparent';
            eCtx.shadowOffsetX = 0;
            eCtx.shadowOffsetY = 0;
            
            // Clear a larger area to ensure no artifacts remain
            eCtx.clearRect(cX - 5, cY - 5, e.width + 10, e.height + 10);
            
            // Reset stroke properties
            eCtx.strokeStyle = 'transparent';
            eCtx.lineWidth = 0;
            
            // Set color for the Destroyer - use only the base color
            eCtx.fillStyle = e.color;
            
            // True barbell shape - small circles at ends with thin connecting line
            
            // Make circles much smaller (1/3 of height)
            const circleRadius = e.height * 0.33;
            const centerY = cY + e.height/2;
            
            // Position circles at the far edges of the width
            const leftCircleX = cX + circleRadius;
            const rightCircleX = cX + e.width - circleRadius;
            
            // Draw thin connecting line between circles
            const lineHeight = e.height * 0.15; // Very thin line
            eCtx.fillRect(leftCircleX, centerY - lineHeight/2, rightCircleX - leftCircleX, lineHeight);
            
            // Draw left circle
            eCtx.beginPath();
            eCtx.arc(leftCircleX, centerY, circleRadius, 0, Math.PI * 2);
            eCtx.fill();
            
            // Draw right circle
            eCtx.beginPath();
            eCtx.arc(rightCircleX, centerY, circleRadius, 0, Math.PI * 2);
            eCtx.fill();
            
            // Restore the context state when done
            eCtx.restore();
            break;case'Bomber':eCtx.fillStyle = e.color;
            eCtx.beginPath();
            // Peak is shifted forward (to the right by default) by 1/4 of width from center
            // Original center top: cX + e.width / 2, cY
            // New peak: cX + (e.width / 2) + (e.width / 4) = cX + e.width * 0.75, cY
            const peakX = cX + e.width * 0.75;

            eCtx.moveTo(peakX, cY);                             // Forward peak (topmost point)
            
            // Right side (front/main body)
            eCtx.lineTo(cX + e.width, cY + e.height * 0.4);     // Wingtip leading edge, slightly down
            eCtx.lineTo(cX + e.width * 0.85, cY + e.height);    // Wingtip trailing edge, bottom right

            // Left side (rear/main body)
            eCtx.lineTo(cX + e.width * 0.15, cY + e.height);    // Wingtip trailing edge, bottom left
            eCtx.lineTo(cX, cY + e.height * 0.4);               // Other wingtip leading edge, slightly down
            
            eCtx.closePath();
            eCtx.fill();

            break;
        case'humanoid':
            eCtx.fillStyle=e.color;
            
            // Draw head
            eCtx.beginPath();
            eCtx.arc(cX+e.width/2, cY+e.height*.25, e.width/2.5, 0, Math.PI*2);
            eCtx.fill();
            
            // Draw body
            eCtx.fillRect(cX+e.width*.3, cY+e.height*.4, e.width*.4, e.height*.6);
            
            // Draw MUCH BIGGER, more visible arms (same color as body)
            
            if (e.isFalling) {
                // When falling, arms wave UPWARD (different animation than when abducted)
                // Left arm waving upward - MUCH bigger
                eCtx.save();
                eCtx.translate(cX+e.width*.3, cY+e.height*.45);
                eCtx.rotate(-Math.PI/2 - e.armAngle); // Point more upward with inverse animation
                eCtx.fillRect(-e.width*.05, 0, e.width*.35, e.height*.5); // Much bigger
                eCtx.restore();
                
                // Right arm waving upward - MUCH bigger
                eCtx.save();
                eCtx.translate(cX+e.width*.7, cY+e.height*.45);
                eCtx.rotate(Math.PI/2 + e.armAngle); // Point more upward with inverse animation
                eCtx.fillRect(-e.width*.15, 0, e.width*.35, e.height*.5); // Much bigger
                eCtx.restore();
            } else if (e.isAbducted) {
                // When abducted, arms wave DOWNWARD (original animation)
                // Left arm waving downward - MUCH bigger
                eCtx.save();
                eCtx.translate(cX+e.width*.3, cY+e.height*.45);
                eCtx.rotate(-Math.PI/4 + e.armAngle);
                eCtx.fillRect(-e.width*.05, 0, e.width*.35, e.height*.5); // Much bigger
                eCtx.restore();
                
                // Right arm waving downward - MUCH bigger
                eCtx.save();
                eCtx.translate(cX+e.width*.7, cY+e.height*.45);
                eCtx.rotate(Math.PI/4 - e.armAngle);
                eCtx.fillRect(-e.width*.15, 0, e.width*.35, e.height*.5); // Much bigger
                eCtx.restore();
            } else {
                // Static arms when not falling or abducted - MUCH bigger
                // Left arm - extend much further outward
                eCtx.save();
                eCtx.translate(cX+e.width*.3, cY+e.height*.45);
                eCtx.rotate(-Math.PI/4); // Horizontal angle
                eCtx.fillRect(-e.width*.05, 0, e.width*.4, e.height*.4); // Much bigger
                eCtx.restore();
                
                // Right arm - extend much further outward
                eCtx.save();
                eCtx.translate(cX+e.width*.7, cY+e.height*.45);
                eCtx.rotate(Math.PI/4); // Horizontal angle
                eCtx.fillRect(-e.width*.2, 0, e.width*.4, e.height*.4); // Much bigger
                eCtx.restore();
            }
            
            // Draw parachute when falling
            if (e.isFalling && e.parachuteOpened) {
                // Parachute strings
                eCtx.strokeStyle='#CCCCCC';
                eCtx.beginPath();
                eCtx.moveTo(cX+e.width/2, cY);
                eCtx.lineTo(cX, cY-e.height*1.2);
                eCtx.moveTo(cX+e.width/2, cY);
                eCtx.lineTo(cX+e.width, cY-e.height*1.2);
                eCtx.stroke();
                
                // Parachute dome
                eCtx.beginPath();
                eCtx.strokeStyle='#DDDDDD';
                eCtx.fillStyle='rgba(200, 200, 200, 0.3)';
                eCtx.arc(cX+e.width/2, cY-e.height*1.2, e.width*2, Math.PI, 0, false);
                eCtx.fill();
                eCtx.stroke();
            }
            break;
        case'player_projectile':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.moveTo(cX,cY+e.height/2);eCtx.lineTo(cX+e.width*.7,cY);eCtx.lineTo(cX+e.width,cY+e.height/2);eCtx.lineTo(cX+e.width*.7,cY+e.height);eCtx.closePath();eCtx.fill();break;
        
        case'laser':
            // Draw a bright laser bullet with rounded ends
            
            // Create a bright glowing effect
            eCtx.save();
            
            // Outer glow (larger, more transparent)
            eCtx.globalAlpha = 0.3;
            eCtx.fillStyle = '#FFAA00'; // Orange-yellow glow
            
            // Draw rounded rectangle with arc caps for outer glow
            eCtx.beginPath();
            const glowRadius = e.height * 1.5;
            const glowWidth = e.width + glowRadius * 2;
            
            // Left cap (semicircle)
            eCtx.arc(cX + glowRadius, cY + e.height/2, glowRadius, Math.PI/2, Math.PI*1.5);
            
            // Top line
            eCtx.lineTo(cX + glowWidth - glowRadius, cY);
            
            // Right cap (semicircle)
            eCtx.arc(cX + glowWidth - glowRadius, cY + e.height/2, glowRadius, Math.PI*1.5, Math.PI/2);
            
            // Bottom line
            eCtx.lineTo(cX + glowRadius, cY + e.height);
            
            eCtx.closePath();
            eCtx.fill();
            
            // Middle layer (medium brightness)
            eCtx.globalAlpha = 0.6;
            eCtx.fillStyle = '#FFDD00';
            
            // Draw rounded rectangle for middle layer
            eCtx.beginPath();
            const midRadius = e.height * 1;
            const midWidth = e.width + midRadius;
            
            // Left cap
            eCtx.arc(cX + midRadius, cY + e.height/2, midRadius, Math.PI/2, Math.PI*1.5);
            
            // Top line
            eCtx.lineTo(cX + midWidth, cY);
            
            // Right cap
            eCtx.arc(cX + midWidth, cY + e.height/2, midRadius, Math.PI*1.5, Math.PI/2);
            
            // Bottom line
            eCtx.lineTo(cX + midRadius, cY + e.height);
            
            eCtx.closePath();
            eCtx.fill();
            
            // Core (bright white)
            eCtx.globalAlpha = 1.0;
            eCtx.fillStyle = '#FFFFFF';
            
            // Draw rounded rectangle for core
            eCtx.beginPath();
            const coreRadius = e.height / 2;
            
            // Left cap
            eCtx.arc(cX + coreRadius, cY + coreRadius, coreRadius, Math.PI, 0, true);
            
            // Right side
            eCtx.lineTo(cX + e.width, cY + coreRadius);
            
            // Right cap
            eCtx.arc(cX + e.width, cY + coreRadius, coreRadius, 0, Math.PI, true);
            
            // Left side
            eCtx.lineTo(cX + coreRadius, cY + e.height);
            
            eCtx.closePath();
            eCtx.fill();
            
            eCtx.restore();
            break;
            
        case'enemy_projectile':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.arc(cX+e.width/2,cY+e.height/2,e.width/2,0,Math.PI*2);eCtx.fill();break;
        case'shrapnel':
            // Draw a glowing shrapnel dot with a bright outer glow
            // Outer glow (larger, semi-transparent)
            eCtx.save();
            eCtx.fillStyle = 'rgba(255, 140, 0, 0.6)';
            eCtx.beginPath();
            eCtx.arc(cX+e.width/2, cY+e.height/2, e.width, 0, Math.PI*2);
            eCtx.fill();
            
            // Middle glow (orange-yellow)
            eCtx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            eCtx.beginPath();
            eCtx.arc(cX+e.width/2, cY+e.height/2, e.width * 0.7, 0, Math.PI*2);
            eCtx.fill();
            
            // Center (solid, bright)
            eCtx.fillStyle = e.color; // Bright red core
            eCtx.beginPath();
            eCtx.arc(cX+e.width/2, cY+e.height/2, e.width * 0.4, 0, Math.PI*2);
            eCtx.fill();
            eCtx.restore();
            break;
        case'bomb':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.moveTo(cX+e.width/2,cY);eCtx.lineTo(cX+e.width,cY+e.height/2);eCtx.lineTo(cX+e.width/2,cY+e.height);eCtx.lineTo(cX,cY+e.height/2);eCtx.closePath();eCtx.fill();break;default:eCtx.fillRect(cX,cY,e.width,e.height)}}
        function drawRadar(){ /* Minified */ radarDiv.innerHTML='';if(!player.worldX&&player.worldX!==0)return;const rS=radarDiv.offsetWidth/PLANET_WIDTH;const rH=radarDiv.offsetHeight;let pRX=player.worldX*rS;let pD=document.createElement('div');pD.className='radar-dot player-dot';pD.style.left=`${pRX}px`;pD.style.top=`${rH/2}px`;radarDiv.appendChild(pD);humanoids.forEach(h=>{if(!h.isAbducted){let hRX=h.worldX*rS;let hD=document.createElement('div');hD.className='radar-dot human-dot';hD.style.left=`${hRX}px`;hD.style.top=`${rH-4}px`;radarDiv.appendChild(hD)}});enemies.forEach(e=>{let eRX=e.worldX*rS;let rTop=e.y/CANVAS_HEIGHT*rH;rTop=clamp(rTop,2,rH-2);let eD=document.createElement('div');eD.className=`radar-dot ${e.type==='Mutant'?'mutant-dot':'enemy-dot'}`;eD.style.left=`${eRX}px`;eD.style.top=`${rTop}px`;radarDiv.appendChild(eD)})}
        function updateUI(){ /* Minified */ scoreUI.textContent=score;livesUI.textContent=lives;bombsUI.textContent=smartBombs;waveUI.textContent=currentWave;if(player.shieldEnergy!==undefined){shieldFillUI.style.width=`${player.shieldEnergy/PLAYER_MAX_SHIELD_ENERGY*100}%`}}
        // Track game time and frame timing
        let lastTime = 0;
        const TARGET_FRAME_TIME = 16.67; // ~60 FPS in ms
        let accumulatedTime = 0;
        
        // Time-step based game loop for consistent speed across platforms
        function gameLoop(timestamp) {
            // Calculate the time delta in milliseconds
            let realDt = timestamp - lastTime;
            lastTime = timestamp;
            
            // Cap the delta time to prevent huge jumps if game is backgrounded
            // or the system is under heavy load
            if (!realDt || realDt > 100) realDt = TARGET_FRAME_TIME;
            
            // Accumulate time and update with fixed time steps
            accumulatedTime += realDt;
            
            // Process the game logic in fixed time step increments
            // This ensures consistent movement regardless of frame rate
            const maxSteps = 3; // Prevent spiral of death in very slow scenarios
            let steps = 0;
            
            while (accumulatedTime >= TARGET_FRAME_TIME && steps < maxSteps) {
                // Fixed time step for physics/game updates
                if (gameRunning && !gameOverState) {
                    handleInput();
                    updatePlayer(TARGET_FRAME_TIME);
                    updateProjectiles(TARGET_FRAME_TIME);
                    updateEnemies(TARGET_FRAME_TIME);
                    updateHumanoids(TARGET_FRAME_TIME);
                    updateParticles(TARGET_FRAME_TIME);
                    collisionDetection();
                    checkWaveCompletion();
                }
                
                accumulatedTime -= TARGET_FRAME_TIME;
                steps++;
            }
            
            // Draw is performed once per frame regardless of the number of update steps
            draw();
            
            if (gameRunning || gameOverState || 
                (!gameRunning && !gameOverState && messageOverlay.style.display === 'flex')) {
                updateUI();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Draw enemy previews in the enemy key section using the exact same drawing code as the game
        function drawEnemyPreviews() {
            // Draw Abductor preview (Lander)
            const abductorCanvas = document.getElementById('abductor-preview');
            if (abductorCanvas) {
                const abductorCtx = abductorCanvas.getContext('2d');
                abductorCtx.clearRect(0, 0, abductorCanvas.width, abductorCanvas.height);
                
                const mockAbductor = {
                    type: 'Lander',
                    width: LANDER_WIDTH,
                    height: LANDER_HEIGHT,
                    color: '#FF0000'
                };
                
                // Center the ship in the preview canvas
                const centerX = (abductorCanvas.width - mockAbductor.width) / 2;
                const centerY = (abductorCanvas.height - mockAbductor.height) / 2;
                
                // Use the exact same drawing function as in the game
                drawSpecificEntity(abductorCtx, mockAbductor, centerX, centerY);
            }
            
            // Draw Mutant preview
            const mutantCanvas = document.getElementById('mutant-preview');
            if (mutantCanvas) {
                const mutantCtx = mutantCanvas.getContext('2d');
                mutantCtx.clearRect(0, 0, mutantCanvas.width, mutantCanvas.height);
                
                const mockMutant = {
                    type: 'Mutant',
                    width: MUTANT_WIDTH,
                    height: MUTANT_HEIGHT,
                    color: '#FF8800'
                };
                
                // Center the ship in the preview canvas
                const centerX = (mutantCanvas.width - mockMutant.width) / 2;
                const centerY = (mutantCanvas.height - mockMutant.height) / 2;
                
                // Use the exact same drawing function as in the game
                drawSpecificEntity(mutantCtx, mockMutant, centerX, centerY);
            }
            
            // Draw Bomber preview
            const bomberCanvas = document.getElementById('bomber-preview');
            if (bomberCanvas) {
                const bomberCtx = bomberCanvas.getContext('2d');
                bomberCtx.clearRect(0, 0, bomberCanvas.width, bomberCanvas.height);
                
                const mockBomber = {
                    type: 'Bomber',
                    width: BOMBER_WIDTH,
                    height: BOMBER_HEIGHT,
                    color: '#AA0044'
                };
                
                // Center the ship in the preview canvas
                const centerX = (bomberCanvas.width - mockBomber.width) / 2;
                const centerY = (bomberCanvas.height - mockBomber.height) / 2;
                
                // Use the exact same drawing function as in the game
                drawSpecificEntity(bomberCtx, mockBomber, centerX, centerY);
            }
            
            // Draw Destroyer preview - match exactly how it appears in game
            const destroyerCanvas = document.getElementById('destroyer-preview');
            if (destroyerCanvas) {
                // Get a fresh context and clear everything
                const ctx = destroyerCanvas.getContext('2d');
                ctx.clearRect(0, 0, destroyerCanvas.width, destroyerCanvas.height);
                
                // Create a mock destroyer that matches the game entity
                const mockDestroyer = {
                    type: 'Destroyer',
                    width: DESTROYER_WIDTH,
                    height: DESTROYER_HEIGHT,
                    color: '#0088FF'
                };
                
                // Position in the center of the preview
                const centerX = (destroyerCanvas.width - mockDestroyer.width) / 2;
                const centerY = (destroyerCanvas.height - mockDestroyer.height) / 2;
                
                // Draw using the exact same drawing function as in the game
                // This ensures it looks identical
                drawSpecificEntity(ctx, mockDestroyer, centerX, centerY);
            }
        }
        
        // Draw enemy previews when the message overlay is shown
        function setupEnemyKeyDisplayEvents() {
            // Use the existing messageOverlay reference instead of redeclaring it
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'style' && 
                        messageOverlay.style.display === 'flex') {
                        // The message overlay was shown
                        setTimeout(drawEnemyPreviews, 10);
                    }
                });
            });
            
            // Start observing the message overlay for display changes
            observer.observe(messageOverlay, { attributes: true });
        }
        
        // Setup key events and draw initial previews when page loads
        window.addEventListener('load', function() {
            setupEnemyKeyDisplayEvents();
            // Initial draw attempt
            setTimeout(drawEnemyPreviews, 100);
        });
    </script>
</body>
</html>
