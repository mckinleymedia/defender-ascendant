<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defender Ascendant</title>
    <style>
        body {
            margin: 0;
            background-color: #000000; /* Deep black for space */
            color: #00FFFF; /* Cyan for text */
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column; /* Stack canvas and UI */
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative; /* For positioning UI elements over/around canvas */
            border: 2px solid #00FFFF;
            box-shadow: 0 0 15px #00FFFF, 0 0 25px #00FFFF inset;
            background-color: #001018; /* Dark blue-ish space backdrop */
        }
        canvas {
            display: block; /* Removes extra space below canvas */
            background-image:
                radial-gradient(circle at 1px 1px, rgba(255,255,255,0.3) 1px, transparent 0),
                radial-gradient(circle at 10px 10px, rgba(255,255,255,0.15) 1px, transparent 0);
            background-size: 30px 30px; /* Creates a subtle starfield */
        }
        #ui-radar-container {
            width: 80%;
            max-width: 800px; /* Match canvas width */
            margin-top: 5px;
            height: 60px; /* Increased height for radar and other info */
            position: relative;
            background-color: rgba(0, 20, 20, 0.6);
            border: 1px solid #00AAAA;
            border-top: none; /* Connects visually if canvas has bottom border */
            box-sizing: border-box;
        }
        #radar {
            width: 100%;
            height: 25px; /* Dedicated radar strip */
            background-color: rgba(0, 10, 10, 0.7);
            border-bottom: 1px solid #007777;
            position: relative; /* For positioning dots */
            overflow: hidden;
        }
        .ui-text {
            padding: 0 10px;
            font-size: clamp(12px, 2vw, 16px); /* Responsive font size */
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 35px; /* Remaining height in ui-radar-container */
        }
        .score, .lives, .bombs, .shield-status, .wave {
             text-shadow: 0 0 5px #00FFFF;
        }
        #shield-bar-container {
            display: inline-block;
            width: 80px;
            height: 10px;
            background-color: #003333;
            border: 1px solid #00AAAA;
            border-radius: 3px;
            overflow: hidden;
            margin-left: 5px;
        }
        #shield-fill {
            display: block;
            height: 100%;
            width: 100%;
            background-color: #00FFFF;
            transition: width 0.2s ease-out;
        }
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 550px;
            text-align: center;
            background-color: rgba(0, 10, 15, 0.9);
            padding: 20px 25px;
            border: 2px solid #00FFFF;
            border-radius: 15px;
            box-shadow: 0 0 20px #00FFFF, 0 0 30px #00FFFF inset;
            display: none;
            z-index: 100;
            flex-direction: column;
            align-items: center;
        }
        #message-overlay > p { margin: 5px 0; }
        #main-message-title {
            font-size: clamp(30px, 7vw, 48px);
            font-weight: bold;
            color: #FF00FF;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.6), 0 0 4px #FF00FF;
            margin-bottom: 15px;
        }
        #secondary-message-content {
            font-size: clamp(15px, 3vw, 18px);
            line-height: 1.7;
            color: #00FFFF;
            margin-bottom: 20px;
            white-space: pre-line;
        }
        #action-button-container { margin-top: 15px; }
        #action-button {
            background: linear-gradient(145deg, #005050, #003030);
            color: #FFFF00; border: 2px solid #FFFF00; border-radius: 8px;
            padding: 12px 25px; font-size: clamp(18px, 4vw, 24px); font-weight: bold;
            cursor: pointer; text-shadow: 0 0 5px #000000;
            box-shadow: 0 0 8px #FFFF00, 0 0 15px #FFFF00 inset;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            display: flex; flex-direction: column; align-items: center;
        }
        #action-button:hover {
            background: linear-gradient(145deg, #007070, #005050);
            box-shadow: 0 0 12px #FFFF00, 0 0 20px #FFFF00 inset, 0 0 5px #FFFFFF;
        }
        #action-button-main-text { display: block; }
        #action-button-subtext { display: block; font-size: clamp(10px, 2vw, 12px); font-weight: normal; color: #CCCCCC; margin-top: 4px; }

        .radar-dot { position: absolute; transform: translateY(-50%); }
        .player-dot { width: 6px; height: 16px; background-color: #00FF00; top: 50%; box-shadow: 0 0 3px #00FF00; }
        .human-dot { width: 4px; height: 4px; background-color: #FFFFFF; bottom: 3px; border-radius: 50%; box-shadow: 0 0 3px #FFFFFF; }
        .enemy-dot { width: 4px; height: 4px; background-color: #FF0000; top: 3px; box-shadow: 0 0 3px #FF0000; }
        .mutant-dot { width: 5px; height: 5px; background-color: #FF8800; top: 3px; animation: pulse 1s infinite; box-shadow: 0 0 4px #FF8800; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="message-overlay">
            <p id="main-message-title">Defender Ascendant</p>
            <p id="secondary-message-content"></p>
            <div id="action-button-container">
                <button id="action-button">
                    <span id="action-button-main-text">Start</span>
                    <span id="action-button-subtext">or press Enter</span>
                </button>
            </div>
        </div>
    </div>
    <div id="ui-radar-container">
        <div id="radar"></div>
        <div class="ui-text">
            <div class="score">Score: <span id="score-value">0</span></div>
            <div class="wave">Wave: <span id="wave-value">1</span></div>
            <div>Shield: <span id="shield-bar-container"><span id="shield-fill"></span></span></div>
            <div>Bombs: <span id="bombs-value">3</span></div>
            <div class="lives">Lives: <span id="lives-value">3</span></div>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const CANVAS_WIDTH = 800; const CANVAS_HEIGHT = 600; const PLANET_WIDTH = CANVAS_WIDTH * 4;
        const GROUND_LEVEL = CANVAS_HEIGHT - 40; const STAR_COUNT = 200;

        // Player
        const PLAYER_WIDTH = 36; const PLAYER_HEIGHT = 18; const PLAYER_THRUST = 0.3;
        const PLAYER_MAX_SPEED = 6; const PLAYER_FRICTION = 0.95; const PLAYER_FIRE_RATE = 180;
        const PLAYER_PROJECTILE_SPEED = 10; const PLAYER_PROJECTILE_WIDTH = 12; const PLAYER_PROJECTILE_HEIGHT = 4;
        const PLAYER_MAX_SHIELD_ENERGY = 100; const PLAYER_SHIELD_DURATION = 2500;
        const PLAYER_SHIELD_RECHARGE_RATE = 2; const PLAYER_SHIELD_ACTIVATION_COST = 35;
        const PLAYER_INVULNERABILITY_DURATION = 2000; const HYPERSPACE_COOLDOWN = 5000;
        const PLAYER_APPEAR_OFFSET = PLAYER_WIDTH * 2; 

        // Humanoids & Enemies
        const HUMANOID_COUNT_PER_WAVE_MULTIPLIER = 8; const HUMANOID_WIDTH = 10; const HUMANOID_HEIGHT = 18;
        const HUMANOID_FALL_SPEED = 2; const HUMANOID_RESCUE_POINTS = 500;
        const LANDER_WIDTH = 32; const LANDER_HEIGHT = 24; const LANDER_SPEED = 1.8; const LANDER_POINTS = 150;
        const MUTANT_WIDTH = 34; const MUTANT_HEIGHT = 26; const MUTANT_SPEED = 2.5;
        const MUTANT_FIRE_RATE = 1500; const MUTANT_POINTS = 300;
        const ENEMY_PROJECTILE_SPEED = 4; const ENEMY_PROJECTILE_WIDTH = 8; const ENEMY_PROJECTILE_HEIGHT = 8;

        // Explosion
        const EXPLOSION_PARTICLE_COUNT = 25; const EXPLOSION_FLASH_MAX_RADIUS = 50;
        const EXPLOSION_FLASH_DURATION = 200; const EXPLOSION_PARTICLE_LIFE = 600;

        // --- Game State Variables ---
        let canvas, ctx;
        let gameRunning = false, gameOverState = false;
        let score = 0, lives = 3, smartBombs = 3, currentWave = 1;
        let worldOffsetX = 0;
        let player = {}, humanoids = [], enemies = [], projectiles = { player: [], enemy: [] }, particles = [], stars = [];
        let keys = {};

        let scoreUI, livesUI, bombsUI, shieldFillUI, waveUI, radarDiv;
        let messageOverlay, mainMessageTitle, secondaryMessageContent;
        let actionButton, actionButtonMainText, actionButtonSubtext;

        function random(min, max) { return Math.random() * (max - min) + min; }
        function clamp(value, min, max) { return Math.min(Math.max(value, min), max); }
        function getDistance(x1, y1, x2, y2) { const dx = x1 - x2, dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        
        function worldToCanvasX(worldX) { // This function is primarily for drawWrappedEntity
            return worldX - worldOffsetX;
        }

        window.onload = function() {
            canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
            scoreUI = document.getElementById('score-value'); livesUI = document.getElementById('lives-value');
            bombsUI = document.getElementById('bombs-value'); shieldFillUI = document.getElementById('shield-fill');
            waveUI = document.getElementById('wave-value'); radarDiv = document.getElementById('radar');
            messageOverlay = document.getElementById('message-overlay');
            mainMessageTitle = document.getElementById('main-message-title');
            secondaryMessageContent = document.getElementById('secondary-message-content');
            actionButton = document.getElementById('action-button');
            actionButtonMainText = document.getElementById('action-button-main-text');
            actionButtonSubtext = document.getElementById('action-button-subtext');
            document.addEventListener('keydown', e => { keys[e.code] = true; handleGlobalKeys(e); });
            document.addEventListener('keyup', e => { keys[e.code] = false; });
            actionButton.addEventListener('click', handleActionButtonClick);
            createStars(); showStartScreen(); gameLoop(0);
        };

        function handleActionButtonClick() {
            if (!gameRunning || gameOverState) {
                if (gameOverState) { resetGame(); }
                else if (mainMessageTitle.textContent.includes("Cleared")) { resetGame(true); }
                startGame();
            }
        }
        function handleGlobalKeys(e) { if (e.code === 'Enter') { handleActionButtonClick(); } }

        function showStartScreen() {
            mainMessageTitle.textContent = "Defender Ascendant";
            secondaryMessageContent.innerHTML = `Save the Humanoids!\n\nControls:\nArrows or A/W/S/D: Move Ship\nSpace or Ctrl: Shoot\nShift: Activate Shield\nB: Smart Bomb\nH: Hyperspace`;
            actionButtonMainText.textContent = "Start"; actionButtonSubtext.textContent = "or press Enter";
            messageOverlay.style.display = 'flex'; gameOverState = false; gameRunning = false;
        }
        function startGame() {
            if (!gameRunning) {
                gameRunning = true; gameOverState = false; messageOverlay.style.display = 'none';
                if (!player.worldX && player.worldX !== 0) { resetGame(); }
            }
        }
        function resetGame(isNewWave = false) {
            if (!isNewWave) { score = 0; lives = 3; smartBombs = 3; currentWave = 1; }
            player = {
                type: 'player', worldX: PLANET_WIDTH / 2, y: GROUND_LEVEL - PLAYER_HEIGHT - 50,
                width: PLAYER_WIDTH, height: PLAYER_HEIGHT, vx: 0, vy: 0, facingDirection: 1,
                color: '#00FF00', shieldEnergy: PLAYER_MAX_SHIELD_ENERGY, isShieldActive: false,
                shieldActivationTime: 0, lastShotTime: 0, isInvulnerable: false,
                invulnerabilityTimer: 0, lastHyperspaceTime: 0, hyperspaceActive: false
            };
            projectiles.player = []; projectiles.enemy = []; enemies = []; humanoids = []; particles = [];
            worldOffsetX = (player.worldX - CANVAS_WIDTH / 2 + PLANET_WIDTH) % PLANET_WIDTH;
            spawnHumanoids(); spawnWaveEnemies(); updateUI();
        }

        function createStars() {  stars=[];for(let i=0;i<STAR_COUNT;i++){stars.push({x:random(0,CANVAS_WIDTH),y:random(0,CANVAS_HEIGHT),size:random(.5,2),parallax:random(.1,.5)})} }
        function spawnHumanoids() {  const count=HUMANOID_COUNT_PER_WAVE_MULTIPLIER;humanoids=[];for(let i=0;i<count;i++){humanoids.push({type:'humanoid',worldX:random(0,PLANET_WIDTH),y:GROUND_LEVEL-HUMANOID_HEIGHT,width:HUMANOID_WIDTH,height:HUMANOID_HEIGHT,color:'#FFFFFF',isAbducted:false,abductor:null,isFalling:false,isSafe:true})} }
        function spawnWaveEnemies() {  enemies=[];const landerCount=3+currentWave*2;for(let i=0;i<landerCount;i++){enemies.push({type:'Lander',worldX:random(0,PLANET_WIDTH),y:random(50,CANVAS_HEIGHT/2),width:LANDER_WIDTH,height:LANDER_HEIGHT,vx:0,vy:0,color:'#FF0000',targetHuman:null,isCarryingHuman:false,state:'patrolling',stateTimer:random(1e3,3e3)})} }

        function handleInput() {  if(!gameRunning||gameOverState||player.hyperspaceActive)return;let hInput=0;if(keys['ArrowLeft']||keys['KeyA'])hInput=-1;if(keys['ArrowRight']||keys['KeyD'])hInput=1;if(hInput!==0){player.vx+=PLAYER_THRUST*hInput;player.facingDirection=hInput}if(keys['ArrowUp']||keys['KeyW'])player.vy-=PLAYER_THRUST;if(keys['ArrowDown']||keys['KeyS'])player.vy+=PLAYER_THRUST;if(keys['Space']||keys['ControlLeft']){if(Date.now()-player.lastShotTime>PLAYER_FIRE_RATE){let pSpawnX=player.worldX+(player.facingDirection===1?player.width:-PLAYER_PROJECTILE_WIDTH);projectiles.player.push({type:'player_projectile',worldX:pSpawnX,y:player.y+player.height/2-PLAYER_PROJECTILE_HEIGHT/2,width:PLAYER_PROJECTILE_WIDTH,height:PLAYER_PROJECTILE_HEIGHT,speed:PLAYER_PROJECTILE_SPEED*player.facingDirection,color:'#FFFF00'});player.lastShotTime=Date.now();createParticleEffect(pSpawnX+(player.facingDirection===1?0:PLAYER_PROJECTILE_WIDTH),player.y+player.height/2,'#FFA500',3,2,false,50)}}if(keys['KeyB']&&smartBombs>0&&!player.isShieldActive){activateSmartBomb();smartBombs--;keys['KeyB']=false}if((keys['ShiftLeft']||keys['ShiftRight'])&&!player.isShieldActive&&player.shieldEnergy>=PLAYER_SHIELD_ACTIVATION_COST){player.isShieldActive=true;player.shieldEnergy-=PLAYER_SHIELD_ACTIVATION_COST;player.shieldActivationTime=Date.now();keys['ShiftLeft']=keys['ShiftRight']=false}if(keys['KeyH']&&Date.now()-player.lastHyperspaceTime>HYPERSPACE_COOLDOWN){activateHyperspace();keys['KeyH']=false} }

        function updatePlayer(dt) {
            if (player.hyperspaceActive) return;

            const oldWorldX = player.worldX; 

            player.vx *= PLAYER_FRICTION;
            player.vy *= PLAYER_FRICTION;
            player.vx = clamp(player.vx, -PLAYER_MAX_SPEED, PLAYER_MAX_SPEED);
            player.vy = clamp(player.vy, -PLAYER_MAX_SPEED, PLAYER_MAX_SPEED);
            
            let nextRawWorldX = oldWorldX + player.vx; 
            player.y = clamp(player.y + player.vy, 0, GROUND_LEVEL - player.height);

            if (player.vx > 0 && nextRawWorldX >= PLANET_WIDTH) { 
                player.worldX = nextRawWorldX % PLANET_WIDTH; 
                worldOffsetX = (player.worldX - PLAYER_APPEAR_OFFSET + PLANET_WIDTH) % PLANET_WIDTH;
            } else if (player.vx < 0 && nextRawWorldX < 0) { 
                player.worldX = (nextRawWorldX % PLANET_WIDTH + PLANET_WIDTH) % PLANET_WIDTH; 
                worldOffsetX = (player.worldX - (CANVAS_WIDTH - PLAYER_APPEAR_OFFSET - player.width) + PLANET_WIDTH) % PLANET_WIDTH;
            } else {
                player.worldX = (nextRawWorldX + PLANET_WIDTH) % PLANET_WIDTH; 

                const screenEdgeBuffer = CANVAS_WIDTH / 3.5;
                // **FIXED HERE:** Use the correct calculation for playerCanvasX for scrolling logic
                const playerCanvasX = (player.worldX - worldOffsetX + PLANET_WIDTH) % PLANET_WIDTH;

                if (playerCanvasX < screenEdgeBuffer && player.vx < 0) {
                    worldOffsetX = (worldOffsetX + player.vx + PLANET_WIDTH) % PLANET_WIDTH;
                } else if (playerCanvasX > CANVAS_WIDTH - screenEdgeBuffer && player.vx > 0) {
                    worldOffsetX = (worldOffsetX + player.vx + PLANET_WIDTH) % PLANET_WIDTH;
                }
            }
            worldOffsetX = (worldOffsetX + PLANET_WIDTH) % PLANET_WIDTH;

            if (player.isShieldActive) { if (Date.now() - player.shieldActivationTime > PLAYER_SHIELD_DURATION) { player.isShieldActive = false; deflectFrozenProjectiles(); } }
            else { player.shieldEnergy = Math.min(PLAYER_MAX_SHIELD_ENERGY, player.shieldEnergy + (PLAYER_SHIELD_RECHARGE_RATE * (dt / 1000))); }
            if (player.isInvulnerable) { player.invulnerabilityTimer -= dt; if (player.invulnerabilityTimer <= 0) player.isInvulnerable = false; }
        }

        function updateProjectiles(dt) {  projectiles.player.forEach((p,i)=>{p.worldX=(p.worldX+p.speed+PLANET_WIDTH)%PLANET_WIDTH;const d=Math.abs(p.worldX-(worldOffsetX+CANVAS_WIDTH/2));if(Math.min(d,PLANET_WIDTH-d)>CANVAS_WIDTH*.85)projectiles.player.splice(i,1)});projectiles.enemy.forEach((p,i)=>{p.worldX=(p.worldX+p.vx+PLANET_WIDTH)%PLANET_WIDTH;p.y+=p.vy;const cX=worldToCanvasX(p.worldX);if(cX<-p.width||cX>CANVAS_WIDTH+p.width||p.y<-p.height||p.y>CANVAS_HEIGHT+p.height)projectiles.enemy.splice(i,1)}) }
        function updateEnemies(dt) {  for(let i=enemies.length-1;i>=0;i--){let e=enemies[i];if(e.type==='Lander')updateLander(e,dt);if(e.type==='Mutant')updateMutant(e,dt);e.worldX=(e.worldX+e.vx+PLANET_WIDTH)%PLANET_WIDTH;e.y+=e.vy;} }
        function updateLander(l, dt) {  l.stateTimer-=dt;switch(l.state){case'patrolling':l.vx=Math.sin(Date.now()*.001+l.worldX*.1)*LANDER_SPEED*.5;l.vy=Math.cos(Date.now()*.0008+l.worldX*.08)*LANDER_SPEED*.3;l.y=clamp(l.y,50,GROUND_LEVEL-l.height-HUMANOID_HEIGHT-20);if(l.stateTimer<=0){l.state='seeking';l.stateTimer=random(2e3,5e3)}break;case'seeking':if(!l.targetHuman||l.targetHuman.isAbducted||!l.targetHuman.isSafe)l.targetHuman=findClosestHuman(l);if(l.targetHuman){let dx=l.targetHuman.worldX-l.worldX;if(Math.abs(dx)>PLANET_WIDTH/2)dx=dx>0?dx-PLANET_WIDTH:dx+PLANET_WIDTH;const ang=Math.atan2(l.targetHuman.y-l.height-l.y,dx);l.vx=Math.cos(ang)*LANDER_SPEED;l.vy=Math.sin(ang)*LANDER_SPEED;if(getDistance(l.worldX,l.y,l.targetHuman.worldX,l.targetHuman.y-l.height)<l.height*1.5){l.state='abducting';l.isCarryingHuman=true;l.targetHuman.isAbducted=true;l.targetHuman.abductor=l;l.targetHuman.isSafe=false}}else{l.state='patrolling';l.stateTimer=random(3e3,6e3)}if(l.stateTimer<=0&&l.state==='seeking'){l.state='patrolling';l.stateTimer=random(3e3,6e3)}break;case'abducting':l.vx=0;l.vy=-LANDER_SPEED*.8;if(l.targetHuman){l.targetHuman.worldX=l.worldX;l.targetHuman.y=l.y+l.height/2}if(l.y<-l.height){if(l.targetHuman){transformToMutant(l.targetHuman,l.worldX,10);let idx=humanoids.indexOf(l.targetHuman);if(idx!==-1)humanoids.splice(idx,1)}enemies.splice(enemies.indexOf(l),1)}break;}}
        function updateMutant(m, dt) {  const pCX=worldToCanvasX(player.worldX),mCX=worldToCanvasX(m.worldX);const ang=Math.atan2(player.y-m.y,pCX-mCX);m.vx=Math.cos(ang)*MUTANT_SPEED;m.vy=Math.sin(ang)*MUTANT_SPEED;if(Date.now()-(m.lastShotTime||0)>MUTANT_FIRE_RATE){projectiles.enemy.push({type:'enemy_projectile',worldX:m.worldX+m.width/2,y:m.y+m.height/2,vx:Math.cos(ang)*ENEMY_PROJECTILE_SPEED,vy:Math.sin(ang)*ENEMY_PROJECTILE_SPEED,width:ENEMY_PROJECTILE_WIDTH,height:ENEMY_PROJECTILE_HEIGHT,color:'#FF8800'});m.lastShotTime=Date.now();}}
        function findClosestHuman(e){  let c=null,mD=Infinity;humanoids.forEach(h=>{if(!h.isAbducted&&h.isSafe){let dX=Math.abs(h.worldX-e.worldX);let dist=Math.min(dX,PLANET_WIDTH-dX);if(dist<mD){mD=dist;c=h;}}});return c;}
        function transformToMutant(human,x,y){  enemies.push({type:'Mutant',worldX:x,y:y,width:MUTANT_WIDTH,height:MUTANT_HEIGHT,vx:0,vy:0,color:'#FF6347',lastShotTime:0});createExplosion(x,y,'#FF6347');}
        function updateHumanoids(dt){  humanoids.forEach(h=>{if(h.isFalling){h.y+=HUMANOID_FALL_SPEED;if(h.y>=GROUND_LEVEL-h.height){h.y=GROUND_LEVEL-h.height;h.isFalling=false;h.isSafe=true;}}});}
        function updateParticles(dt){  for(let i=particles.length-1;i>=0;i--){let p=particles[i];p.life-=dt;if(p.life<=0){particles.splice(i,1);continue;}if(p.type==='explosion_flash'){p.radius=p.maxRadius*(1-(p.life/p.initialLife));p.alpha=0.8*(p.life/p.initialLife);}else{p.vy+=0.05;p.vx*=0.99;if(typeof p.worldX !=='undefined'){p.worldX=(p.worldX+p.vx+PLANET_WIDTH)%PLANET_WIDTH;}else{p.x+=p.vx;}p.y+=p.vy;p.alpha=p.life/p.initialLife;}}}
        function createParticleEffect(x,y,color,count,speedRange,isScreenSpace=false, life = EXPLOSION_PARTICLE_LIFE, particleType = 'debris'){  for(let i=0;i<count;i++){let p={y:y,vx:random(-speedRange,speedRange),vy:random(-speedRange-1,speedRange-3),size:random(1,4),color:color,life:random(life*0.5,life),initialLife:life, alpha:1.0, type: particleType};if(isScreenSpace){p.x=x;}else{p.worldX=x;}particles.push(p);}}
        function createExplosion(worldX, y, baseColor) {  particles.push({type:'explosion_flash',worldX:worldX,y:y,radius:0,maxRadius:EXPLOSION_FLASH_MAX_RADIUS,color:'rgba(255,255,200,0.9)',life:EXPLOSION_FLASH_DURATION,initialLife:EXPLOSION_FLASH_DURATION,alpha:0.9});const colors=[baseColor,'#FFA500','#FF4500','#FFD700'];for(let i=0;i<EXPLOSION_PARTICLE_COUNT;i++){particles.push({type:'debris',worldX:worldX,y:y,vx:random(-5,5),vy:random(-6,1),size:random(2,5),color:colors[Math.floor(random(0,colors.length))],life:random(EXPLOSION_PARTICLE_LIFE*.7,EXPLOSION_PARTICLE_LIFE),initialLife:EXPLOSION_PARTICLE_LIFE,alpha:1.0});}}
        function collisionDetection(){  if(!gameRunning||gameOverState||player.hyperspaceActive)return;const pCX=worldToCanvasX(player.worldX),pRect={x:pCX,y:player.y,width:player.width,height:player.height};for(let i=projectiles.player.length-1;i>=0;i--){let p=projectiles.player[i];if(!p)continue;const pR={x:worldToCanvasX(p.worldX),y:p.y,width:p.width,height:p.height};for(let j=enemies.length-1;j>=0;j--){let e=enemies[j];if(!e)continue;const eR={x:worldToCanvasX(e.worldX),y:e.y,width:e.width,height:e.height};if(rectIntersect(pR,eR)){createExplosion(e.worldX,e.y+e.height/2,e.color);score+=(e.type==='Lander'?LANDER_POINTS:MUTANT_POINTS);projectiles.player.splice(i,1);if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}enemies.splice(j,1);i--;break}}}for(let i=projectiles.enemy.length-1;i>=0;i--){let p=projectiles.enemy[i];if(!p)continue;const pR={x:worldToCanvasX(p.worldX),y:p.y,width:p.width,height:p.height};if(player.isShieldActive&&rectIntersect(pR,{x:pRect.x-5,y:pRect.y-5,width:player.width+10,height:player.height+10})){createParticleEffect(p.worldX,p.y,'#00FFFF',5,2,false,100,'shield_hit');projectiles.enemy.splice(i,1)}else if(!player.isInvulnerable&&rectIntersect(pR,pRect)){projectiles.enemy.splice(i,1);playerHit();break}}if(!player.isInvulnerable&&!player.isShieldActive){for(let i=enemies.length-1;i>=0;i--){let e=enemies[i];if(!e)continue;const eR={x:worldToCanvasX(e.worldX),y:e.y,width:e.width,height:e.height};if(rectIntersect(pRect,eR)){playerHit();createExplosion(e.worldX,e.y+e.height/2,e.color);enemies.splice(i,1);break}}}for(let i=humanoids.length-1;i>=0;i--){let h=humanoids[i];if(!h)continue;if(h.isFalling){const hR={x:worldToCanvasX(h.worldX),y:h.y,width:h.width,height:h.height};if(rectIntersect(pRect,hR)){h.isFalling=false;h.y=GROUND_LEVEL-h.height;h.isSafe=true;score+=HUMANOID_RESCUE_POINTS;createParticleEffect(player.worldX,player.y,'#00FF00',10,3,false,200,'rescue_flash')}}}}
        function rectIntersect(r1,r2){  return!(r2.x>r1.x+r1.width||r2.x+r2.width<r1.x||r2.y>r1.y+r1.height||r2.y+r2.height<r1.y);}
        function activateSmartBomb(){  createExplosion(worldOffsetX+CANVAS_WIDTH/2,CANVAS_HEIGHT/2,'#FFFFFF');for(let i=enemies.length-1;i>=0;i--){let e=enemies[i];const eCX=worldToCanvasX(e.worldX);if(eCX>-e.width&&eCX<CANVAS_WIDTH&&e.y>-e.height&&e.y<CANVAS_HEIGHT){if(e.type !=='Mutant'){createExplosion(e.worldX,e.y+e.height/2,e.color)}else{createParticleEffect(e.worldX,e.y+e.height/2,e.color,15,4)}if(e.isCarryingHuman&&e.targetHuman){e.targetHuman.isAbducted=false;e.targetHuman.abductor=null;e.targetHuman.isFalling=true}enemies.splice(i,1);score+=50}}}
        function deflectFrozenProjectiles(){}
        function activateHyperspace(){  player.lastHyperspaceTime=Date.now();player.hyperspaceActive=true;createParticleEffect(player.worldX,player.y+player.height/2,'#FFFFFF',50,8,false,300,'hyperspace_trail');setTimeout(()=>{player.worldX=random(0,PLANET_WIDTH);player.y=random(CANVAS_HEIGHT*.2,GROUND_LEVEL-player.height-50);player.vx=0;player.vy=0;worldOffsetX=(player.worldX-CANVAS_WIDTH/2+PLANET_WIDTH)%PLANET_WIDTH;player.hyperspaceActive=false;player.isInvulnerable=true;player.invulnerabilityTimer=1e3;createParticleEffect(player.worldX,player.y+player.height/2,'#FFFFFF',30,5,false,300,'hyperspace_arrival')},750)}
        function playerHit(){  if(player.isInvulnerable||player.hyperspaceActive)return;lives--;createExplosion(player.worldX,player.y+player.height/2,player.color);if(lives<=0){triggerGameOver()}else{player.worldX=(worldOffsetX+CANVAS_WIDTH/2+PLANET_WIDTH)%PLANET_WIDTH;player.y=GROUND_LEVEL-PLAYER_HEIGHT-50;player.vx=0;player.vy=0;player.isInvulnerable=true;player.invulnerabilityTimer=PLAYER_INVULNERABILITY_DURATION;player.shieldEnergy=PLAYER_MAX_SHIELD_ENERGY;player.isShieldActive=false}}
        function triggerGameOver(){  gameRunning=false;gameOverState=true;mainMessageTitle.textContent="Game Over!";secondaryMessageContent.textContent=`Final Score: ${score}`;actionButtonMainText.textContent="Restart";actionButtonSubtext.textContent="or press Enter";messageOverlay.style.display='flex'}
        function checkWaveCompletion(){  const activeHostiles=enemies.filter(e=>e.type==='Lander'||e.type==='Mutant').length;if(gameRunning&&!gameOverState&&activeHostiles===0&&humanoids.length>0){gameRunning=false;currentWave++;score+=humanoids.length*100;mainMessageTitle.textContent=`Wave ${currentWave-1} Cleared!`;secondaryMessageContent.textContent=`Humanoid Bonus: ${humanoids.length*100} points!`;actionButtonMainText.textContent="Next Wave";actionButtonSubtext.textContent="or press Enter";messageOverlay.style.display='flex'}else if(gameRunning&&!gameOverState&&humanoids.length===0&&activeHostiles>0){triggerGameOver();mainMessageTitle.textContent="Planet Lost!";secondaryMessageContent.textContent=`All humanoids abducted. Final Score: ${score}`}}
        function draw(){ /* Minified for brevity, logic mostly unchanged from v2.5, uses drawWrappedEntity */ if(!ctx)return;ctx.fillStyle='#000510';ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);stars.forEach(s=>{const sX=(s.x-(worldOffsetX*s.parallax)%CANVAS_WIDTH+CANVAS_WIDTH)%CANVAS_WIDTH;ctx.fillStyle=`rgba(200,220,255,${Math.max(.3,s.size/1.5*.8)})`;ctx.fillRect(sX,s.y,s.size,s.size)});ctx.strokeStyle='#0088AA';ctx.lineWidth=1.5;for(let j=0;j<3;j++){ctx.beginPath();let pF=.2+j*.2,a=15+j*10,f=.01+j*.005;for(let x=0;x<CANVAS_WIDTH;x++){let wX=x+worldOffsetX*pF,tY=GROUND_LEVEL+10+j*10+Math.sin(wX*f)*a;if(x===0)ctx.moveTo(x,tY);else ctx.lineTo(x,tY)}ctx.globalAlpha=.3+j*.2;ctx.stroke()}ctx.globalAlpha=1;humanoids.forEach(h=>drawWrappedEntity(ctx,h));projectiles.player.forEach(p=>drawWrappedEntity(ctx,p));projectiles.enemy.forEach(p=>drawWrappedEntity(ctx,p));enemies.forEach(e=>drawWrappedEntity(ctx,e));if(!player.hyperspaceActive&&player.worldX!==undefined){ctx.globalAlpha=(player.isInvulnerable&&Math.floor(player.invulnerabilityTimer/100)%2===0)?.5:1;drawWrappedEntity(ctx,player);if(player.isShieldActive){const pCX=worldToCanvasX(player.worldX);ctx.strokeStyle='#00FFFF';ctx.lineWidth=2;ctx.beginPath();ctx.arc(pCX+player.width/2,player.y+player.height/2,player.width*.8,0,Math.PI*2);ctx.stroke();ctx.fillStyle='rgba(0,255,255,0.1)';ctx.fill()}ctx.globalAlpha=1}particles.forEach(p=>{ctx.globalAlpha=p.alpha;let pCX=typeof p.worldX !=='undefined'?worldToCanvasX(p.worldX):p.x;if(p.type==='explosion_flash'){ctx.beginPath();ctx.arc(pCX,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=p.color;ctx.fill()}else{ctx.fillStyle=p.color;ctx.fillRect(pCX,p.y,p.size,p.size)}});ctx.globalAlpha=1;drawRadar()}
        function drawWrappedEntity(ctx, entity) {  if(!entity||typeof entity.worldX==='undefined'||typeof entity.y==='undefined'||typeof entity.width==='undefined'||typeof entity.height==='undefined'){return}const canvasX=worldToCanvasX(entity.worldX);drawSpecificEntity(ctx,entity,canvasX,entity.y);if(canvasX<entity.width+20){drawSpecificEntity(ctx,entity,canvasX+PLANET_WIDTH,entity.y)}if(canvasX+entity.width>CANVAS_WIDTH-20){drawSpecificEntity(ctx,entity,canvasX-PLANET_WIDTH,entity.y)}}
        function drawSpecificEntity(eCtx,e,cX,cY){  if(cX+e.width<0||cX>CANVAS_WIDTH||cY+e.height<0||cY>CANVAS_HEIGHT){return}eCtx.fillStyle=e.color;eCtx.strokeStyle=e.color;eCtx.lineWidth=1.5;switch(e.type){case'player':eCtx.beginPath();if(player.facingDirection===1){eCtx.moveTo(cX,cY);eCtx.lineTo(cX+e.width,cY+e.height/2);eCtx.lineTo(cX,cY+e.height)}else{eCtx.moveTo(cX+e.width,cY);eCtx.lineTo(cX,cY+e.height/2);eCtx.lineTo(cX+e.width,cY+e.height)}eCtx.closePath();eCtx.fill();eCtx.fillStyle='#AAAAFF';eCtx.fillRect(cX+e.width/2-3,cY+e.height/2-3,6,6);let tAH=false,tS='none';if(keys['ArrowLeft']||keys['KeyA']){tAH=true;tS='right'}else if(keys['ArrowRight']||keys['KeyD']){tAH=true;tS='left'}if(tAH){eCtx.fillStyle='#FFA500';let tX=tS==='left'?cX-5:cX+e.width;eCtx.fillRect(tX,cY+e.height/4,5,e.height/2)}if(keys['ArrowUp']||keys['KeyW']){eCtx.fillStyle='#FFA500';eCtx.fillRect(cX+e.width/2-2.5,cY+e.height,5,5)}else if(keys['ArrowDown']||keys['KeyS']){eCtx.fillStyle='#FFA500';eCtx.fillRect(cX+e.width/2-2.5,cY-5,5,5)}break;case'Lander':eCtx.beginPath();eCtx.arc(cX+e.width/2,cY+e.height/2,e.width/2,Math.PI,0);eCtx.fill();eCtx.fillRect(cX,cY+e.height/2,e.width,e.height/2);eCtx.beginPath();eCtx.moveTo(cX+e.width*.2,cY+e.height*.8);eCtx.lineTo(cX+e.width*.1,cY+e.height*1.2);eCtx.moveTo(cX+e.width*.8,cY+e.height*.8);eCtx.lineTo(cX+e.width*.9,cY+e.height*1.2);eCtx.stroke();break;case'Mutant':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.moveTo(cX+e.width/2,cY);eCtx.lineTo(cX+e.width,cY+e.height*.7);eCtx.lineTo(cX+e.width*.7,cY+e.height);eCtx.lineTo(cX+e.width*.3,cY+e.height);eCtx.lineTo(cX,cY+e.height*.7);eCtx.closePath();eCtx.fill();eCtx.fillStyle='#FFFF00';eCtx.beginPath();eCtx.arc(cX+e.width/2,cY+e.height*.4,e.width*.1,0,Math.PI*2);eCtx.fill();break;case'humanoid':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.arc(cX+e.width/2,cY+e.height*.25,e.width/2.5,0,Math.PI*2);eCtx.fill();eCtx.fillRect(cX+e.width*.3,cY+e.height*.4,e.width*.4,e.height*.6);if(e.isFalling){eCtx.strokeStyle='#CCCCCC';eCtx.beginPath();eCtx.moveTo(cX+e.width/2,cY);eCtx.lineTo(cX,cY-e.height*.5);eCtx.moveTo(cX+e.width/2,cY);eCtx.lineTo(cX+e.width,cY-e.height*.5);eCtx.stroke()}break;case'player_projectile':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.moveTo(cX,cY+e.height/2);eCtx.lineTo(cX+e.width*.7,cY);eCtx.lineTo(cX+e.width,cY+e.height/2);eCtx.lineTo(cX+e.width*.7,cY+e.height);eCtx.closePath();eCtx.fill();eCtx.fillStyle='rgba(255,255,100,0.5)';eCtx.fillRect(cX-e.width*.3,cY+e.height*.25,e.width*.5,e.height*.5);break;case'enemy_projectile':eCtx.fillStyle=e.color;eCtx.beginPath();eCtx.arc(cX+e.width/2,cY+e.height/2,e.width/2,0,Math.PI*2);eCtx.fill();break;default:eCtx.fillRect(cX,cY,e.width,e.height)}}
        function drawRadar(){ radarDiv.innerHTML='';if(!player.worldX&&player.worldX!==0)return;const rS=radarDiv.offsetWidth/PLANET_WIDTH;let pRX=player.worldX*rS;let pD=document.createElement('div');pD.className='radar-dot player-dot';pD.style.left=`${pRX}px`;radarDiv.appendChild(pD);humanoids.forEach(h=>{if(!h.isAbducted){let hRX=h.worldX*rS;let hD=document.createElement('div');hD.className='radar-dot human-dot';hD.style.left=`${hRX}px`;radarDiv.appendChild(hD)}});enemies.forEach(e=>{let eRX=e.worldX*rS;let eD=document.createElement('div');eD.className=`radar-dot ${e.type==='Mutant'?'mutant-dot':'enemy-dot'}`;eD.style.left=`${eRX}px`;radarDiv.appendChild(eD)})}
        function updateUI(){ scoreUI.textContent=score;livesUI.textContent=lives;bombsUI.textContent=smartBombs;waveUI.textContent=currentWave;if(player.shieldEnergy!==undefined){shieldFillUI.style.width=`${player.shieldEnergy/PLAYER_MAX_SHIELD_ENERGY*100}%`}}
        let lastTime=0;function gameLoop(timestamp){let dt=timestamp-lastTime;if(!dt||dt>100)dt=16.67;lastTime=timestamp;if(gameRunning&&!gameOverState){handleInput();updatePlayer(dt);updateProjectiles(dt);updateEnemies(dt);updateHumanoids(dt);updateParticles(dt);collisionDetection();checkWaveCompletion()}draw();if(gameRunning||gameOverState||!gameRunning&&!gameOverState&&messageOverlay.style.display==='flex'){updateUI()}requestAnimationFrame(gameLoop)}
    </script>
</body>
</html>
